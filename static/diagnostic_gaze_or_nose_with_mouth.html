<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Brocha: Ojos/Iris o Nariz + Boca (ROI default affine)</title>

<script src="https://webgazer.cs.brown.edu/webgazer.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh"></script>

<style>
Â  html,body{margin:0;padding:0;height:100%;overflow:hidden;background:#0f1115;color:#fff}
Â  #wrap{position:relative;width:100%;height:100vh}
Â  #topbar{position:absolute;top:10px;left:10px;right:10px;display:flex;gap:8px;flex-wrap:wrap;background:rgba(0,0,0,.45);padding:8px 10px;border-radius:10px;align-items:center;z-index:10000}
Â  .btn{appearance:none;border:0;padding:6px 10px;border-radius:10px;cursor:pointer;background:#22272e;color:#fff;font-weight:600}
Â  .btn.primary{background:#00e676;color:#111}
Â  .btn.warn{background:#ff5252}
Â  .sp{margin-left:auto;font:12px/1.2 monospace;opacity:.9}
Â  #stage{position:absolute;inset:62px 10px 10px 10px;border-radius:10px;background:#10131a;overflow:hidden}
Â  #canvas{position:absolute;inset:0;width:100%;height:100%}
Â  #cursor{position:absolute;width:20px;height:20px;border:2px solid rgba(255,255,255,.95);border-radius:50%;pointer-events:none;transform:translate(-50%,-50%);display:none}
Â  #status{position:absolute;bottom:10px;left:10px;right:10px;display:flex;gap:10px;align-items:center;background:rgba(255,255,255,.06);padding:8px 10px;border-radius:10px;z-index:9999}
Â  #modeTag{font-weight:700;background:#1f2937;padding:4px 8px;border-radius:8px}
Â  #marPanel{display:flex;align-items:center;gap:8px;flex:1}
Â  #marBar{position:relative;height:10px;flex:1;background:#2b2f3a;border-radius:6px;overflow:hidden}
Â  #marFill{position:absolute;top:0;left:0;height:100%;width:0%;background:#00e676}
Â  #marThr{position:absolute;top:-3px;width:2px;height:16px;background:#ff5252;left:50%}
Â  #marVal{min-width:140px;text-align:right;font:12px/1 monospace;opacity:.9}
Â  #preview{position:absolute;top:10px;right:10px;width:300px;height:225px;background:#000a;border-radius:8px;display:none;z-index:5000}
Â  #dbg{position:absolute;right:10px;bottom:10px;background:rgba(0,0,0,.55);padding:6px 8px;border-radius:8px;font:12px/1.2 monospace}
Â  video#rawVideo{display:none}
Â  #errbar{position:absolute;bottom:0;left:0;right:0;background:#ff3344;color:#100;padding:6px 10px;font:12px/1.3 monospace;display:none;z-index:10001}
Â  .roi-overlay{position:absolute;inset:0;pointer-events:none}
Â  .roi-rect{position:absolute;border:2px dashed rgba(0,230,118,.9);border-radius:8px;box-shadow:0 0 0 200vmax rgba(0,0,0,.45) inset}
Â  .calib-target{position:absolute;width:18px;height:18px;border-radius:50%;background:#00e676;box-shadow:0 0 0 6px rgba(0,230,118,.2);transform:translate(-50%,-50%);pointer-events:auto;cursor:crosshair}
Â  .calib-target.wait{background:#fbbf24; box-shadow:0 0 0 6px rgba(251,191,36,.25)}
Â  .calib-target.done{background:#22d3ee; box-shadow:0 0 0 6px rgba(34,211,238,.25)}
Â  .badge{padding:2px 6px;border-radius:6px;background:#1f2937;margin-left:6px;font:12px/1 monospace}
</style>
</head>
<body>
<div id="wrap">
Â  <div id="topbar">
Â  Â  <button id="testCam" class="btn">ğŸ¥ Probar cÃ¡mara</button>
Â  Â  <button id="modeFace" class="btn">1) Test de Boca</button>
Â  Â  <button id="modeGaze" class="btn">2) Test de Movimiento</button>
Â  Â  <button id="modeBrush" class="btn primary">3) Iniciar Brocha</button>

Â  Â  <button id="btnRoi" class="btn">ğŸ–±ï¸ ROI</button>
Â  Â  <button id="btnCalRoi" class="btn">ğŸ¯ CalibraciÃ³n OJOS (ROI)</button>
Â  Â  <button id="btnResetCal" class="btn warn">â™»ï¸ Reset CalibraciÃ³n</button>

Â  Â  <button id="togglePreview" class="btn">ğŸ‘ï¸ Preview</button>
Â  Â  <button id="clear" class="btn warn">ğŸ§¹ Limpiar</button>
Â  Â  <button id="savePng" class="btn">ğŸ–¼ï¸ PNG</button>
Â  Â  <button id="saveCsv" class="btn">ğŸ“„ CSV</button>
Â  Â  <span class="sp" id="count">pts: 0</span>
Â  </div>

Â  <div id="stage">
Â  Â  <canvas id="canvas"></canvas>
Â  Â  <div id="cursor"></div>
Â  Â  <canvas id="preview"></canvas>
Â  Â  <div id="dbg" style="display:none"></div>
Â  Â  <video id="rawVideo" playsinline autoplay muted></video>
Â  Â  <div class="roi-overlay" id="roiOverlay"></div>
Â  </div>

Â  <div id="status">
Â  Â  <span id="modeTag">Modo: Test de Boca</span>
Â  Â  <div id="marPanel">
Â  Â  Â  <span>MAR:</span>
Â  Â  Â  <div id="marBar"><div id="marFill"></div><div id="marThr"></div></div>
Â  Â  Â  <span id="marVal">â€”</span>
Â  Â  Â  <span class="badge" id="ctlBadge">Control: OJOS (Iris)</span>
Â  Â  </div>
Â  </div>

Â  <div id="errbar"></div>
</div>

<script>
(function(){
Â  // ---------- errores ----------
Â  const errbar=document.getElementById('errbar');
Â  function showErr(msg){ errbar.textContent='âš ï¸ '+msg; errbar.style.display='block'; }
Â  window.onerror=(m,src,l,c)=>showErr((m||'Error')+(l?` @${l}:${c||0}`:''));
Â  window.onunhandledrejection=(ev)=>showErr('Promise rejection: '+(ev.reason?.message||ev.reason||''));

Â  // ---------- config ----------
Â  const CFG = Object.assign({
Â  Â  brush:8, alpha:.20, mouthThr:.28, debug:true, controlMode:'eyes',
Â  Â  useIris:true,
Â  Â  invertX:false, invertY:false,
Â  Â  gainX:1.15, gainY:1.15,
Â  Â  deadzonePx:6, maxStepPx:22, medianN:5, mouthHys:.05,
Â  Â  marMedianN:5, marEmaAlpha:.30,
Â  Â  marUseEyeScale:true, marEyeFactor:0.35,
Â  Â  detConf:.5, trackConf:.5,
Â  }, window.DIAG_CFG||{});

Â  // ---------- DOM ----------
Â  const stageEl=document.getElementById('stage');
Â  const canvas=document.getElementById('canvas'); const ctx=canvas.getContext('2d');
Â  const cursor=document.getElementById('cursor');
Â  const preview=document.getElementById('preview'); const pctx=preview.getContext('2d');
Â  const dbg=document.getElementById('dbg');
Â  const rawVideo=document.getElementById('rawVideo');
Â  const countEl=document.getElementById('count'); const modeTag=document.getElementById('modeTag');
Â  const marVal=document.getElementById('marVal'); const marFill=document.getElementById('marFill'); const marThr=document.getElementById('marThr');
Â  const roiOverlay=document.getElementById('roiOverlay');

Â  // ---------- estado ----------
Â  let mode='face';
Â  let brush=CFG.brush, alpha=CFG.alpha, mouthThr=CFG.mouthThr;
Â  let dpr=1, W=0, H=0, pts=[], last=null;

Â  // seÃ±ales
Â  let irisN={x:null,y:null};
Â  let nose={x:null,y:null,z:null};
Â  let faceBox=null;

Â  // afÃ­n irisNâ†’pÃ­xeles (por defecto: ROI), y flag de calibraciÃ³n cargada
Â  let A=[1,0,0,1], b=[0,0];
Â  let hasCalib=false;
Â  const LS_KEY='diag_calib_affine_irisN_v1';
Â  const ROI_KEY='diag_roi_norm_v3';
Â  let roiNorm = loadJson(ROI_KEY) || {x0:0.08,y0:0.08,x1:0.92,y1:0.92};

Â  // MAR (boca)
Â  let marHist=[], marEma=null, isPainting=false;

Â  // ---------- tamaÃ±o ----------
Â  function resize(){
Â  Â  dpr=Math.min(window.devicePixelRatio||1,2);
Â  Â  const r=stageEl.getBoundingClientRect();
Â  Â  canvas.width=Math.floor(r.width*dpr); canvas.height=Math.floor(r.height*dpr);
Â  Â  canvas.style.width=r.width+'px'; canvas.style.height=r.height+'px'; ctx.setTransform(dpr,0,0,dpr,0,0);
Â  Â  preview.width=Math.floor(300*dpr); preview.height=Math.floor(225*dpr);
Â  Â  preview.style.width='300px'; preview.style.height='225px'; pctx.setTransform(dpr,0,0,dpr,0,0);
Â  Â  W=r.width; H=r.height;
Â  Â  drawRoiRect();
Â  Â  if(!hasCalib) setDefaultAffineFromROI();
Â  }
Â  window.addEventListener('resize', resize); resize();

Â  function setDefaultAffineFromROI(){
Â  Â  const r=stageEl.getBoundingClientRect();
Â  Â  const rx0=roiNorm.x0*r.width, ry0=roiNorm.y0*r.height;
Â  Â  const rw =(roiNorm.x1-roiNorm.x0)*r.width;
Â  Â  const rh =(roiNorm.y1-roiNorm.y0)*r.height;
Â  Â  // irisN (0..1) â†’ ROI en pÃ­xeles
Â  Â  A=[rw,0,0,rh];
Â  Â  b=[rx0,ry0];
Â  }

Â  // ---------- UI ----------
Â  document.getElementById('modeFace').onclick=()=>setMode('face');
Â  document.getElementById('modeGaze').onclick=()=>setMode('gmove');
Â  document.getElementById('modeBrush').onclick=()=>setMode('brush');
Â  document.getElementById('togglePreview').onclick=()=>{
Â  Â  const vis=(preview.style.display==='none'||preview.style.display==='')?'block':'none';
Â  Â  preview.style.display=vis; dbg.style.display=vis;
Â  };
Â  document.getElementById('clear').onclick=()=>{ctx.clearRect(0,0,canvas.width,canvas.height); pts=[]; countEl.textContent='pts: 0'; last=null;};
Â  document.getElementById('savePng').onclick=()=>{const a=document.createElement('a'); a.download=`brocha_${Date.now()}.png`; a.href=canvas.toDataURL('image/png'); a.click();};
Â  document.getElementById('saveCsv').onclick=()=>{
Â  Â  const header='t_ms,x,y,mar,mode\n';
Â  Â  const body=pts.map(p=>`${p.t},${Math.round(p.x)},${Math.round(p.y)},${(p.mar??0).toFixed(4)},eyes`).join('\n');
Â  Â  const blob=new Blob([header+body],{type:'text/csv'}); const url=URL.createObjectURL(blob);
Â  Â  const a=document.createElement('a'); a.href=url; a.download=`brocha_eyes_${Date.now()}.csv`; a.click(); URL.revokeObjectURL(url);
Â  };
Â  document.getElementById('btnRoi').onclick = defineRoiWithMouse;
Â  document.getElementById('btnCalRoi').onclick = guidedRoiCalibration;
Â  document.getElementById('btnResetCal').onclick = ()=>{
Â  Â  hasCalib=false; setDefaultAffineFromROI(); saveJson(LS_KEY,null);
Â  Â  alert('CalibraciÃ³n reiniciada (se usa mapeo por defecto al ROI).');
Â  };

Â  function setMode(m){
Â  Â  mode=m;
Â  Â  modeTag.textContent='Modo: '+(m==='face'?'Test de Boca': m==='gmove'?'Test de Movimiento':'Brocha');
Â  Â  if(m==='face') cursor.style.display='none';
Â  }

Â  // ---------- cÃ¡mara ----------
Â  async function startCameraFlow(auto=false){
Â  Â  try{
Â  Â  Â  const stream=await navigator.mediaDevices.getUserMedia({
Â  Â  Â  Â  video:{width:{ideal:1280},height:{ideal:720},frameRate:{ideal:60,max:60},facingMode:"user"},
Â  Â  Â  Â  audio:false
Â  Â  Â  });
Â  Â  Â  rawVideo.srcObject=stream; await rawVideo.play(); errbar.style.display='none';
Â  Â  Â  if(!auto) alert('âœ… CÃ¡mara iniciada.');
Â  Â  }catch(e){
Â  Â  Â  const hintIframe = (window.self !== window.top) ? "\nğŸ‘‰ Si estÃ¡s en Streamlit, embebe el iframe con allow=\"camera; microphone\"." : "";
Â  Â  Â  showErr('No se pudo acceder a la cÃ¡mara: '+(e.name||'')+' â€” '+(e.message||e)+hintIframe+"\nPulsa Â«Probar cÃ¡maraÂ» para reintentar.");
Â  Â  }
Â  }
Â  document.getElementById('testCam').onclick=()=>startCameraFlow(false);
Â  window.addEventListener('load', ()=>startCameraFlow(true));

Â  // ---------- FaceMesh (Iris, boca, nariz) ----------
Â  const faceMesh=new FaceMesh({ locateFile:(f)=>`https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${f}` });
Â  faceMesh.setOptions({ maxNumFaces:3, refineLandmarks:true, minDetectionConfidence: CFG.detConf, minTrackingConfidence: CFG.trackConf });

Â  function bboxOf(lm){let minx=1,miny=1,maxx=0,maxy=0; for(const p of lm){minx=Math.min(minx,p.x); miny=Math.min(miny,p.y); maxx=Math.max(maxx,p.x); maxy=Math.max(maxy,p.y);} return {minx,miny,maxx,maxy,cx:(minx+maxx)/2,cy:(miny+maxy)/2,area:(maxx-minx)*(maxy-miny)};}
Â  function pickMainFace(arr){ if(!arr||!arr.length) return null; let k=0,b=Infinity; for(let i=0;i<arr.length;i++){ const bb=bboxOf(arr[i]); const dc=(bb.cx-0.5)**2+(bb.cy-0.5)**2; const s=dc/(bb.area+1e-6); if(s<b){b=s;k=i;} } return arr[k]; }
Â  function dist2(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }

Â  async function faceLoop(){ try{ if(rawVideo.readyState>=2 && !rawVideo.paused && !rawVideo.ended){ await faceMesh.send({image:rawVideo}); } }catch(e){ showErr('faceLoop: '+e.message); } requestAnimationFrame(faceLoop); }

Â  faceMesh.onResults(res=>{
Â  Â  if(!res.multiFaceLandmarks || !res.multiFaceLandmarks.length) return;
Â  Â  const lm = pickMainFace(res.multiFaceLandmarks); if(!lm) return;

Â  Â  faceBox = bboxOf(lm);
Â  Â  if (faceBox.area < 0.02) return;

Â  Â  // --- Boca (MAR) ---
Â  Â  const mouthH = dist2(lm[13], lm[14]);
Â  Â  const mouthW = dist2(lm[61], lm[291]);
Â  Â  const eyeDstÂ  = dist2(lm[33], lm[263]);
Â  Â  const denom = (CFG.marUseEyeScale) ? Math.max(mouthW, CFG.marEyeFactor*eyeDst) : mouthW;
Â  Â  const marRaw = mouthH / Math.max(1e-6, denom);
Â  Â  marHist.push(marRaw); if(marHist.length>CFG.marMedianN) marHist.shift();
Â  Â  const med = median(marHist); marEma = (marEma==null)? med : CFG.marEmaAlpha*med + (1-CFG.marEmaAlpha)*marEma;
Â  Â  const marUi = Math.max(0, Math.min(0.8, marEma));
Â  Â  marVal.textContent = `raw:${marRaw.toFixed(3)}Â  filt:${marEma.toFixed(3)}`;
Â  Â  marFill.style.width = (marUi/0.8*100).toFixed(0)+'%';
Â  Â  marThr.style.left = (Math.max(0, Math.min(1, mouthThr/0.8))*100).toFixed(0)+'%';

Â  Â  // --- Nariz (por si usas ese modo) ---
Â  Â  const NOSE_IDX=[1,4];
Â  Â  let nz=lm[NOSE_IDX[0]]; for(const idx of NOSE_IDX){ if(lm[idx] && lm[idx].z < nz.z) nz = lm[idx]; }
Â  Â  nose = {x:nz.x, y:nz.y, z:nz.z};

Â  Â  // --- Ojos con Iris â†’ irisN (0..1) ---
Â  Â  const avg = (idxs)=> idxs.reduce((s,i)=>({x:s.x+lm[i].x, y:s.y+lm[i].y}), {x:0,y:0});
Â  Â  const rC=avg([468,469,470,471]); rC.x/=4; rC.y/=4;
Â  Â  const lC=avg([473,474,475,476]); lC.x/=4; lC.y/=4;

Â  Â  const R_L = lm[33], R_R = lm[133], L_L = lm[362], L_R = lm[263];
Â  Â  const R_T = lm[159], R_B = lm[145], L_T = lm[386], L_B = lm[374];

Â  Â  const rW = Math.max(1e-6, Math.abs(R_R.x - R_L.x));
Â  Â  const lW = Math.max(1e-6, Math.abs(L_R.x - L_L.x));
Â  Â  const rH = Math.max(1e-6, Math.abs(R_B.y - R_T.y));
Â  Â  const lH = Math.max(1e-6, Math.abs(L_B.y - L_T.y));

Â  Â  let rx = (rC.x - R_L.x) / rW;
Â  Â  let lx = (lC.x - L_L.x) / lW;
Â  Â  let ry = (rC.y - R_T.y) / rH;
Â  Â  let ly = (lC.y - L_T.y) / lH;

Â  Â  let gxN = (rx + lx) / 2;
Â  Â  let gyN = (ry + ly) / 2;
Â  Â  
Â  Â  if (CFG.invertX) gxN = 1 - gxN;
Â  Â  if (CFG.invertY) gyN = 1 - gyN;

Â  Â  gxN = Math.max(0, Math.min(1, 0.5 + (gxN - 0.5) * CFG.gainX));
Â  Â  gyN = Math.max(0, Math.min(1, 0.5 + (gyN - 0.5) * CFG.gainY));

Â  Â  // Corregir la inversiÃ³n del eje Y
Â  Â  gyN = 1 - gyN;

Â  Â  irisN.x = gxN; irisN.y = gyN;
Â  Â 
Â  Â  // ProyecciÃ³n por la afÃ­n (ROI por defecto o calibrada)
Â  Â  let px, py;
Â  Â  if (CFG.controlMode === 'nose') {
Â  Â  Â  px = W * nose.x;
Â  Â  Â  py = H * nose.y;
Â  Â  } else {
Â  Â  Â  px = A[0]*irisN.x + A[1]*irisN.y + b[0];
Â  Â  Â  py = A[2]*irisN.x + A[3]*irisN.y + b[1];
Â  Â  }
Â  Â  
Â  Â  // Dibujo / cursor
Â  Â  const x = Math.max(0, Math.min(W-1, px));
Â  Â  const y = Math.max(0, Math.min(H-1, py));

Â  Â  if(preview.style.display!=='none' && CFG.debug){
Â  Â  Â  dbg.textContent = `irisN=(${irisN.x.toFixed(2)}, ${irisN.y.toFixed(2)})Â  px=(${x|0},${y|0})Â  hasCalib=${hasCalib}`;
Â  Â  Â  pctx.clearRect(0,0,preview.width,preview.height);
Â  Â  Â  pctx.drawImage(rawVideo,0,0,preview.width,preview.height);
Â  Â  Â  const dot=(u,v,c='#0f0',r=3)=>{pctx.fillStyle=c;pctx.beginPath();pctx.arc(u*preview.width,v*preview.height,r,0,7);pctx.fill();};
Â  Â  Â  [468,469,470,471,473,474,475,476].forEach(i=>dot(lm[i].x,lm[i].y,'#0f0',2.5));
Â  Â  }

Â  Â  if(mode!=='face' && (CFG.controlMode === 'eyes' || CFG.controlMode === 'nose')){
Â  Â  Â  cursor.style.display='block';
Â  Â  Â  cursor.style.left=x+'px'; cursor.style.top=y+'px';
Â  Â  Â  cursor.style.width=(brush*2)+'px'; cursor.style.height=(brush*2)+'px';
Â  Â  } else { cursor.style.display='none'; }

Â  Â  if(mode==='brush' && isPainting){
Â  Â  Â  if(last){
Â  Â  Â  Â  ctx.strokeStyle='rgba(0,200,255,.95)'; ctx.lineWidth=brush; ctx.lineJoin='round'; ctx.lineCap='round';
Â  Â  Â  Â  const mx=(last.x+x)/2, my=(last.y+y)/2;
Â  Â  Â  Â  ctx.beginPath(); ctx.moveTo(last.x,last.y); ctx.quadraticCurveTo(mx,my,x,y); ctx.stroke();
Â  Â  Â  Â  pts.push({t:Date.now(), x, y, mar:marEma});
Â  Â  Â  Â  countEl.textContent = `pts: ${pts.length}`;
Â  Â  Â  }
Â  Â  Â  last = {x,y};
Â  Â  }else{
Â  Â  Â  last = {x,y};
Â  Â  }
Â  });

Â  // ---------- cargar calibraciÃ³n ----------
Â  (function loadCalib(){
Â  Â  const saved = loadJson(LS_KEY);
Â  Â  if(saved && saved.A && saved.b){
Â  Â  Â  A=saved.A; b=saved.b; hasCalib=true;
Â  Â  }else{
Â  Â  Â  hasCalib=false; setDefaultAffineFromROI();
Â  Â  }
Â  })();

Â  // ---------- loop de boca (pintar/no pintar) ----------
Â  function loop(){
Â  Â  if(marEma!=null){
Â  Â  Â  const openThrÂ  = mouthThr + CFG.mouthHys;
Â  Â  Â  const closeThr = mouthThr - CFG.mouthHys;
Â  Â  Â  isPainting = isPainting ? (marEma > closeThr) : (marEma > openThr);
Â  Â  }
Â  Â  requestAnimationFrame(loop);
Â  }
Â  requestAnimationFrame(loop);
Â  requestAnimationFrame(faceLoop);

Â  // ---------- ROI + CalibraciÃ³n ----------
Â  function defineRoiWithMouse(){
Â  Â  alert('Arrastra con el mouse para dibujar el ROI donde colocarÃ© los puntos de calibraciÃ³n.');
Â  Â  const r=stageEl.getBoundingClientRect();
Â  Â  let start=null, rectEl=null;
Â  Â  function onDown(e){
Â  Â  Â  start={x:e.clientX - r.left, y:e.clientY - r.top};
Â  Â  Â  if(!rectEl){ rectEl=document.createElement('div'); rectEl.className='roi-rect'; roiOverlay.appendChild(rectEl); }
Â  Â  Â  placeRect(start.x,start.y,1,1);
Â  Â  Â  window.addEventListener('mousemove',onMove);
Â  Â  Â  window.addEventListener('mouseup',onUp,{once:true});
Â  Â  }
Â  Â  function onMove(e){
Â  Â  Â  const x=e.clientX - r.left, y=e.clientY - r.top;
Â  Â  Â  const x0=Math.min(start.x,x), y0=Math.min(start.y,y);
Â  Â  Â  const x1=Math.max(start.x,x), y1=Math.max(start.y,y);
Â  Â  Â  placeRect(x0,y0, x1-x0, y1-y0);
Â  Â  }
Â  Â  function onUp(){
Â  Â  Â  window.removeEventListener('mousemove',onMove);
Â  Â  Â  const bb=roiOverlay.lastChild.getBoundingClientRect();
Â  Â  Â  const x0=(bb.left - r.left)/r.width, y0=(bb.top - r.top)/r.height;
Â  Â  Â  const x1=(bb.right - r.left)/r.width, y1=(bb.bottom - r.top)/r.height;
Â  Â  Â  roiNorm = {x0:clamp01(x0), y0:clamp01(y0), x1:clamp01(x1), y1:clamp01(y1)};
Â  Â  Â  saveJson(ROI_KEY, roiNorm); drawRoiRect();
Â  Â  Â  if(!hasCalib) setDefaultAffineFromROI();
Â  Â  Â  alert('ROI guardada. Ejecuta la calibraciÃ³n guiada si quieres afinar mÃ¡s.');
Â  Â  }
Â  Â  stageEl.addEventListener('mousedown',onDown,{once:true});
Â  Â  function placeRect(x,y,w,h){ const el=roiOverlay.lastChild; el.style.left=x+'px'; el.style.top=y+'px'; el.style.width=w+'px'; el.style.height=h+'px'; }
Â  }
Â  function drawRoiRect(){
Â  Â  roiOverlay.innerHTML='';
Â  Â  const r=stageEl.getBoundingClientRect();
Â  Â  const x0=roiNorm.x0*r.width, y0=roiNorm.y0*r.height;
Â  Â  const w =(roiNorm.x1-roiNorm.x0)*r.width;
Â  Â  const h =(roiNorm.y1-roiNorm.y0)*r.height;
Â  Â  const rectEl=document.createElement('div');
Â  Â  rectEl.className='roi-rect';
Â  Â  rectEl.style.left=x0+'px'; rectEl.style.top=y0+'px';
Â  Â  rectEl.style.width=w+'px'; rectEl.style.height=h+'px';
Â  Â  roiOverlay.appendChild(rectEl);
Â  }

Â  async function guidedRoiCalibration(){
Â  Â  const r=stageEl.getBoundingClientRect();
Â  Â  const rx0=roiNorm.x0*r.width, ry0=roiNorm.y0*r.height;
Â  Â  const rw =(roiNorm.x1-roiNorm.x0)*r.width;
Â  Â  const rh =(roiNorm.y1-roiNorm.y0)*r.height;

Â  Â  const nx=[0,0.5,1], ny=[0,0.5,1];
Â  Â  const targets=[]; for(const ix of nx) for(const iy of ny){ targets.push({ x: rx0 + ix*rw, y: ry0 + iy*rh }); }

Â  Â  roiOverlay.innerHTML=''; drawRoiRect();
Â  Â  const els=[];
Â  Â  for(const t of targets){
Â  Â  Â  const el=document.createElement('div'); el.className='calib-target wait';
Â  Â  Â  el.style.left=t.x+'px'; el.style.top=t.y+'px';
Â  Â  Â  roiOverlay.appendChild(el); els.push(el);
Â  Â  }

Â  Â  alert('CalibraciÃ³n: clic en cada punto y MIRA ese punto ~1.2s. (Se aprende A,b: irisNâ†’pÃ­xeles)');
Â  Â  const src=[], dst=[];
Â  Â  for(let i=0;i<targets.length;i++){
Â  Â  Â  const el=els[i]; const t=targets[i];
Â  Â  Â  await new Promise(res=>{
Â  Â  Â  Â  const onceClick = async ()=>{
Â  Â  Â  Â  Â  el.classList.remove('wait'); el.classList.add('calib-target');
Â  Â  Â  Â  Â  const samples=[]; const t0=performance.now();
Â  Â  Â  Â  Â  function step(){
Â  Â  Â  Â  Â  Â  const now=performance.now();
Â  Â  Â  Â  Â  Â  if(irisN.x!=null && irisN.y!=null){ samples.push([irisN.x, irisN.y]); }
Â  Â  Â  Â  Â  Â  if(now-t0<1200){ requestAnimationFrame(step); }
Â  Â  Â  Â  Â  Â  else{
Â  Â  Â  Â  Â  Â  Â  const m=mean2(samples);
Â  Â  Â  Â  Â  Â  Â  if(!isNaN(m[0])){ src.push(m); dst.push([t.x, t.y]); }
Â  Â  Â  Â  Â  Â  Â  el.classList.add('done'); res();
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  requestAnimationFrame(step);
Â  Â  Â  Â  };
Â  Â  Â  Â  el.addEventListener('click', onceClick, {once:true});
Â  Â  Â  });
Â  Â  Â  await sleep(120);
Â  Â  }
Â  Â  const sol=lsqAffine(src, dst);
Â  Â  if(sol){ A=sol.A; b=sol.b; hasCalib=true; saveJson(LS_KEY,{A,b}); alert('âœ… CalibraciÃ³n guardada.'); }
Â  Â  else{ alert('No se pudo calibrar (muestras insuficientes).'); }
Â  }

Â  // ---------- utils ----------
Â  function sleep(ms){return new Promise(r=>setTimeout(r,ms));}
Â  function mean2(a){if(!a.length)return[NaN,NaN];const sx=a.reduce((s,v)=>s+v[0],0), sy=a.reduce((s,v)=>s+v[1],0);return[sx/a.length, sy/a.length];}
Â  function median(arr){ if(!arr.length) return NaN; const a=[...arr].sort((x,y)=>x-y), m=Math.floor(a.length/2); return a.length%2 ? a[m] : (a[m-1]+a[m])/2; }
Â  function clamp01(v){return Math.max(0,Math.min(1,v));}
Â  function transpose(A){const m=A.length,n=A[0].length,AT=Array.from({length:n},()=>Array(m).fill(0));for(let i=0;i<m;i++)for(let j=0;j<n;j++)AT[j][i]=A[i][j];return AT;}
Â  function mul(A,B){const m=A.length,n=A[0].length,p=B[0].length,C=Array.from({length:m},()=>Array(p).fill(0));for(let i=0;i<m;i++)for(let k=0;k<n;k++)for(let j=0;j<p;j++)C[i][j]+=A[i][k]*B[k][j];return C;}
Â  function mulVec(A,v){const m=A.length,n=A[0].length,r=Array(m).fill(0);for(let i=0;i<m;i++)for(let j=0;j<n;j++)r[i]+=A[i][j]*v[j];return r;}
Â  function solveGaussian(A,b){const n=A.length,M=A.map((row,i)=>row.concat([b[i]]));for(let i=0;i<n;i++){let max=i;for(let r=i+1;r<n;r++)if(Math.abs(M[r][i])>Math.abs(M[max][i]))max=r;if(Math.abs(M[max][i])<1e-9)return null;[M[i],M[max]]=[M[max],M[i]];const piv=M[i][i];for(let k=i;k<=n;k++)M[i][k]/=piv;for(let r=0;r<n;r++)if(r!==i){const f=M[r][i];for(let k=i;k<=n;k++)M[r][k]-=f*M[i][k];}}return M.map(row=>row[n]);}
Â  function lsqAffine(srcPts,dstPts){
Â  Â  if(!srcPts.length || srcPts.length<3) return null;
Â  Â  const M=[],Z=[];
Â  Â  for(let i=0;i<srcPts.length;i++){
Â  Â  Â  const[gx,gy]=srcPts[i]; const[tx,ty]=dstPts[i];
Â  Â  Â  M.push([gx,gy,0,0,1,0]); Z.push(tx);
Â  Â  Â  M.push([0,0,gx,gy,0,1]); Z.push(ty);
Â  Â  }
Â  Â  const Mt=transpose(M),MtM=mul(Mt,M),MtZ=mulVec(Mt,Z),p=solveGaussian(MtM,MtZ);
Â  Â  return p?{A:[p[0],p[1],p[2],p[3]],b:[p[4],p[5]]}:null;
Â  }
Â  function saveJson(k,v){ try{ if(v==null){localStorage.removeItem(k);} else {localStorage.setItem(k, JSON.stringify(v));} }catch(e){} }
Â  function loadJson(k){ try{ const s=localStorage.getItem(k); return s?JSON.parse(s):null; }catch(e){ return null; } }

})();
</script>
</body>
</html>
