<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Brocha: Ojos/Iris o Nariz + Boca</title>

<!-- OJOS baseline (opcional, dejamos cargado por compatibilidad) -->
<script src="https://webgazer.cs.brown.edu/webgazer.js"></script>
<!-- CARA (FaceMesh con Iris) -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh"></script>

<style>
  html,body{margin:0;padding:0;height:100%;overflow:hidden;background:#0f1115;color:#fff}
  #wrap{position:relative;width:100%;height:100vh}
  #topbar{position:absolute;top:10px;left:10px;right:10px;display:flex;gap:8px;flex-wrap:wrap;
          background:rgba(0,0,0,.45);padding:8px 10px;border-radius:10px;align-items:center;z-index:10000}
  .btn{appearance:none;border:0;padding:6px 10px;border-radius:10px;cursor:pointer;background:#22272e;color:#fff;font-weight:600}
  .btn.primary{background:#00e676;color:#111}
  .btn.warn{background:#ff5252}
  .sp{margin-left:auto;font:12px/1.2 monospace;opacity:.9}
  #stage{position:absolute;inset:62px 10px 10px 10px;border-radius:10px;background:#10131a;overflow:hidden}
  #canvas{position:absolute;inset:0;width:100%;height:100%}
  #cursor{position:absolute;width:20px;height:20px;border:2px solid rgba(255,255,255,.95);border-radius:50%;
          pointer-events:none;transform:translate(-50%,-50%);display:none}
  #status{position:absolute;bottom:10px;left:10px;right:10px;display:flex;gap:10px;align-items:center;
          background:rgba(255,255,255,.06);padding:8px 10px;border-radius:10px;z-index:9999}
  #modeTag{font-weight:700;background:#1f2937;padding:4px 8px;border-radius:8px}
  #marPanel{display:flex;align-items:center;gap:8px;flex:1}
  #marBar{position:relative;height:10px;flex:1;background:#2b2f3a;border-radius:6px;overflow:hidden}
  #marFill{position:absolute;top:0;left:0;height:100%;width:0%;background:#00e676}
  #marThr{position:absolute;top:-3px;width:2px;height:16px;background:#ff5252;left:50%}
  #marVal{min-width:140px;text-align:right;font:12px/1 monospace;opacity:.9}
  #preview{position:absolute;top:10px;right:10px;width:300px;height:225px;background:#000a;border-radius:8px;display:none;z-index:5000}
  video#rawVideo{display:none}
  #errbar{position:absolute;bottom:0;left:0;right:0;background:#ff3344;color:#100;padding:6px 10px;font:12px/1.3 monospace;display:none;z-index:10001}
  .roi-overlay{position:absolute;inset:0;pointer-events:none}
  .roi-rect{position:absolute;border:2px dashed rgba(0,230,118,.9);border-radius:8px;box-shadow:0 0 0 200vmax rgba(0,0,0,.45) inset}
  .calib-target{position:absolute;width:18px;height:18px;border-radius:50%;background:#00e676;
                box-shadow:0 0 0 6px rgba(0,230,118,.2);transform:translate(-50%,-50%);pointer-events:auto;cursor:crosshair}
  .calib-target.wait{background:#fbbf24; box-shadow:0 0 0 6px rgba(251,191,36,.25)}
  .calib-target.done{background:#22d3ee; box-shadow:0 0 0 6px rgba(34,211,238,.25)}
  .badge{padding:2px 6px;border-radius:6px;background:#1f2937;margin-left:6px;font:12px/1 monospace}
</style>
</head>
<body>
<div id="wrap">
  <div id="topbar">
    <button id="testCam" class="btn">üé• Probar c√°mara</button>
    <button id="modeFace" class="btn">1) Test de Boca</button>
    <button id="modeGaze" class="btn">2) Test de Movimiento</button>
    <button id="modeBrush" class="btn primary">3) Iniciar Brocha</button>

    <button id="btnRoi" class="btn">üñ±Ô∏è ROI</button>
    <button id="btnCalRoi" class="btn">üéØ Calibraci√≥n OJOS (ROI)</button>
    <button id="btnResetCal" class="btn warn">‚ôªÔ∏è Reset Calibraci√≥n</button>

    <button id="btnAnchors" class="btn">üîß Anclas anti-drift</button>
    <button id="togglePreview" class="btn">üëÅÔ∏è Preview</button>
    <button id="clear" class="btn warn">üßπ Limpiar</button>
    <button id="savePng" class="btn">üñºÔ∏è PNG</button>
    <button id="saveCsv" class="btn">üìÑ CSV</button>
    <span class="sp" id="count">pts: 0</span>
  </div>

  <div id="stage">
    <canvas id="canvas"></canvas>
    <div id="cursor"></div>
    <canvas id="preview"></canvas>
    <video id="rawVideo" playsinline autoplay muted></video>
    <div class="roi-overlay" id="roiOverlay"></div>
  </div>

  <div id="status">
    <span id="modeTag">Modo: Test de Boca</span>
    <div id="marPanel">
      <span>MAR:</span>
      <div id="marBar"><div id="marFill"></div><div id="marThr"></div></div>
      <span id="marVal">‚Äî</span>
      <span class="badge" id="ctlBadge">Control: OJOS (Iris)</span>
      <span class="badge" id="ancBadge">Anclas: OFF</span>
    </div>
  </div>

  <div id="errbar"></div>
</div>

<script>
(function(){
  // -------- errores visibles --------
  const errbar=document.getElementById('errbar');
  function showErr(msg){ errbar.textContent='‚ö†Ô∏è '+msg; errbar.style.display='block'; }
  window.onerror=(m,src,l,c)=>showErr((m||'Error')+(l?` @${l}:${c||0}`:''));
  window.onunhandledrejection=(ev)=>showErr('Promise rejection: '+(ev.reason?.message||ev.reason||''));

  // -------- config desde Python (controlMode llega como 'eyes' o 'nose') --------
  const CFG = Object.assign({
    brush:8, alpha:.20, mouthThr:.28, debug:true, controlMode:'eyes',
    useIris:true,                    // usar iris para el control por ojos
    deadzonePx:6, maxStepPx:22, medianN:5, mouthHys:.05,
    marMedianN:5, marEmaAlpha:.30,
    marUseEyeScale:true, marEyeFactor:0.35,
    detConf:.5, trackConf:.5,
    snap:{enabled:true,size:64,radius:22,blend:0.7},
    anchors:{enabled:true, dwellMs:300, radiusPx:28, adjust:0.12} // anti-drift
  }, window.DIAG_CFG||{});

  // -------- DOM --------
  const stageEl=document.getElementById('stage');
  const canvas=document.getElementById('canvas'); const ctx=canvas.getContext('2d');
  const cursor=document.getElementById('cursor');
  const preview=document.getElementById('preview'); const pctx=preview.getContext('2d');
  const rawVideo=document.getElementById('rawVideo');
  const countEl=document.getElementById('count'); const modeTag=document.getElementById('modeTag');
  const marVal=document.getElementById('marVal'); const marFill=document.getElementById('marFill'); const marThr=document.getElementById('marThr');
  const roiOverlay=document.getElementById('roiOverlay');
  const ctlBadge=document.getElementById('ctlBadge'); const ancBadge=document.getElementById('ancBadge');

  // -------- estado --------
  let mode='face'; // 'face'|'gmove'|'brush'
  let brush=CFG.brush, alpha=CFG.alpha, mouthThr=CFG.mouthThr;
  let dpr=1, W=0, H=0, pts=[], last=null;

  // se√±ales
  let gaze={x:null,y:null};       // si useIris: calculado con iris; si no: WebGazer
  let nose={x:null,y:null,z:null};
  let faceBox=null;

  // af√≠n ojos
  let A=[1,0,0,1], b=[0,0];
  const LS_KEY='diag_calib_affine_v2';
  const ROI_KEY='diag_roi_norm_v2';
  const ANC_KEY='diag_anchors_on_v1';

  // ROI
  let roiNorm = loadJson(ROI_KEY) || {x0:0.08,y0:0.08,x1:0.92,y1:0.92};

  // MAR
  let marHist=[], marEma=null, isPainting=false;

  // historial para mediana
  let histX=[], histY=[];

  // anclas
  let anchorsOn = loadJson(ANC_KEY) ?? !!CFG.anchors.enabled;
  let dwellStart = null; let currentAnchor = null;

  // worker Kalman
  const kalmanWorker = makeKalmanWorker();
  let kalmanReady = false;
  kalmanWorker.onmessage = (e)=>{
    if(e.data?.ready){ kalmanReady = true; return; }
    if(e.data?.out){ applyFiltered(e.data.out.x, e.data.out.y); }
  };
  // enviar cfg inicial al worker
  kalmanWorker.postMessage({cfg:{procNoise:1e-2, measNoise:2.0, maxStep:CFG.maxStepPx, deadzone:CFG.deadzonePx}});

  // -------- tama√±o --------
  function resize(){
    dpr=Math.min(window.devicePixelRatio||1,2);
    const r=stageEl.getBoundingClientRect();
    canvas.width=Math.floor(r.width*dpr); canvas.height=Math.floor(r.height*dpr);
    canvas.style.width=r.width+'px'; canvas.style.height=r.height+'px'; ctx.setTransform(dpr,0,0,dpr,0,0);
    preview.width=Math.floor(300*dpr); preview.height=Math.floor(225*dpr);
    preview.style.width='300px'; preview.style.height='225px'; pctx.setTransform(dpr,0,0,dpr,0,0);
    W=r.width; H=r.height;
    drawRoiRect();
  }
  window.addEventListener('resize', resize); resize();

  // -------- UI --------
  document.getElementById('modeFace').onclick=()=>setMode('face');
  document.getElementById('modeGaze').onclick=()=>setMode('gmove');
  document.getElementById('modeBrush').onclick=()=>setMode('brush');
  document.getElementById('togglePreview').onclick=()=>{preview.style.display=(preview.style.display==='none'||preview.style.display==='')?'block':'none';};
  document.getElementById('clear').onclick=()=>{ctx.clearRect(0,0,canvas.width,canvas.height); pts=[]; countEl.textContent='pts: 0'; last=null;};
  document.getElementById('savePng').onclick=()=>{const a=document.createElement('a'); a.download=`brocha_${Date.now()}.png`; a.href=canvas.toDataURL('image/png'); a.click();};
  document.getElementById('saveCsv').onclick=()=>{
    const header='t_ms,x,y,mar,mode\n';
    const body=pts.map(p=>`${p.t},${Math.round(p.x)},${Math.round(p.y)},${(p.mar??0).toFixed(4)},${CFG.controlMode}`).join('\n');
    const blob=new Blob([header+body],{type:'text/csv'}); const url=URL.createObjectURL(blob);
    const a=document.createElement('a'); a.href=url; a.download=`brocha_${CFG.controlMode}_${Date.now()}.csv`; a.click(); URL.revokeObjectURL(url);
  };
  document.getElementById('btnRoi').onclick = defineRoiWithMouse;
  document.getElementById('btnCalRoi').onclick = guidedRoiCalibration;
  document.getElementById('btnResetCal').onclick = ()=>{ A=[1,0,0,1]; b=[0,0]; saveJson(LS_KEY,{A,b}); alert('Calibraci√≥n af√≠n reiniciada.'); };
  document.getElementById('btnAnchors').onclick = ()=>{
    anchorsOn = !anchorsOn;
    saveJson(ANC_KEY, anchorsOn);
    ancBadge.textContent = 'Anclas: ' + (anchorsOn?'ON':'OFF');
  };
  ancBadge.textContent = 'Anclas: ' + (anchorsOn?'ON':'OFF');
  ctlBadge.textContent = 'Control: ' + (CFG.controlMode==='nose'?'NARIZ':'OJOS (Iris)');

  function setMode(m){
    mode=m;
    modeTag.textContent='Modo: '+(m==='face'?'Test de Boca': m==='gmove'?'Test de Movimiento':'Brocha');
    if(m==='face') cursor.style.display='none';
  }

  // -------- c√°mara --------
  let gStream=null;
  document.getElementById('testCam').onclick=async ()=>{
    try{
      gStream=await navigator.mediaDevices.getUserMedia({video:{width:640,height:480}});
      rawVideo.srcObject=gStream; await rawVideo.play(); errbar.style.display='none';
      alert('‚úÖ C√°mara iniciada.');
    }catch(e){ showErr('getUserMedia: '+(e.name||'')+' ‚Äî '+(e.message||'')); }
  };

  // -------- FaceMesh (Iris+boca+nariz) --------
  const faceMesh=new FaceMesh({ locateFile:(f)=>`https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${f}` });
  faceMesh.setOptions({
    maxNumFaces:3, refineLandmarks:true,
    minDetectionConfidence: CFG.detConf, minTrackingConfidence: CFG.trackConf
  });

  function bboxOf(lm){let minx=1,miny=1,maxx=0,maxy=0; for(const p of lm){minx=Math.min(minx,p.x); miny=Math.min(miny,p.y); maxx=Math.max(maxx,p.x); maxy=Math.max(maxy,p.y);} return {minx,miny,maxx,maxy,cx:(minx+maxx)/2,cy:(miny+maxy)/2,area:(maxx-minx)*(maxy-miny)};}
  function pickMainFace(arr){ if(!arr||!arr.length) return null; let k=0,b=Infinity; for(let i=0;i<arr.length;i++){ const bb=bboxOf(arr[i]); const dc=(bb.cx-0.5)**2+(bb.cy-0.5)**2; const s=dc/(bb.area+1e-6); if(s<b){b=s;k=i;} } return arr[k]; }
  function dist2(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }
  function lerp(a,b,t){ return a+(b-a)*t; }

  async function faceLoop(){ try{ if(rawVideo.readyState>=2 && !rawVideo.paused && !rawVideo.ended){ await faceMesh.send({image:rawVideo}); } }catch(e){ showErr('faceLoop: '+e.message); } requestAnimationFrame(faceLoop); }

  // iris indices (MediaPipe): 468..471 centro/puntos del iris derecho, 473..476 izquierdo
  const IRIS_R = [468,469,470,471], IRIS_L = [473,474,475,476];
  const EYE_R = [33,133]; // extremos ojo derecho
  const EYE_L = [362,263]; // extremos ojo izquierdo

  faceMesh.onResults(res=>{
    if(!res.multiFaceLandmarks || !res.multiFaceLandmarks.length) return;
    const lm = pickMainFace(res.multiFaceLandmarks); if(!lm) return;

    faceBox = bboxOf(lm);
    if (faceBox.area < 0.02) return; // muy lejos

    // ---------- Boca (MAR robusto) ----------
    const mouthH = dist2(lm[13], lm[14]);
    const mouthW = dist2(lm[61], lm[291]);
    const eyeDst = dist2(lm[33], lm[263]);
    const denom = (CFG.marUseEyeScale) ? Math.max(mouthW, CFG.marEyeFactor * eyeDst) : mouthW;
    const marRaw = mouthH / Math.max(1e-6, denom);

    // mediana + EMA
    marHist.push(marRaw); if(marHist.length>CFG.marMedianN) marHist.shift();
    const med = median(marHist); marEma = (marEma==null)? med : CFG.marEmaAlpha*med + (1-CFG.marEmaAlpha)*marEma;

    // UI
    const marUi = Math.max(0, Math.min(0.8, marEma));
    marVal.textContent = `raw:${marRaw.toFixed(3)}  filt:${marEma.toFixed(3)}`;
    marFill.style.width = (marUi / 0.8 * 100).toFixed(0) + '%';
    marThr.style.left   = (Math.max(0, Math.min(1, mouthThr / 0.8)) * 100).toFixed(0) + '%';

    // ---------- Nariz ----------
    const NOSE_IDX=[1,4];
    let nz = lm[NOSE_IDX[0]];
    for(const idx of NOSE_IDX){ if(lm[idx] && lm[idx].z < nz.z) nz = lm[idx]; }
    nose = {x:nz.x, y:nz.y, z:nz.z};

    // ---------- Ojos con Iris (cursor bruto) ----------
    if(CFG.controlMode==='eyes' && CFG.useIris){
      // centros del iris = media de 4 puntos
      const c = (idxs)=> idxs.reduce((s,i)=>({x:s.x+lm[i].x, y:s.y+lm[i].y}), {x:0,y:0});
      const rC = c(IRIS_R); rC.x/=IRIS_R.length; rC.y/=IRIS_R.length;
      const lC = c(IRIS_L); lC.x/=IRIS_L.length; lC.y/=IRIS_L.length;

      // normalizaci√≥n por cada ojo respecto a su caja (extremos)
      const r0=lm[EYE_R[0]], r1=lm[EYE_R[1]], l0=lm[EYE_L[0]], l1=lm[EYE_L[1]];
      const rx = (rC.x - Math.min(r0.x,r1.x)) / Math.max(1e-6, Math.abs(r0.x-r1.x));
      const ry = (rC.y - Math.min(r0.y,r1.y)) / Math.max(1e-6, Math.abs(r0.y-r1.y));
      const lx = (lC.x - Math.min(l0.x,l1.x)) / Math.max(1e-6, Math.abs(l0.x-l1.x));
      const ly = (lC.y - Math.min(l0.y,l1.y)) / Math.max(1e-6, Math.abs(l0.y-l1.y));

      // mezcla ojos y mapeo a ROI
      const gxN = 1 - Math.max(0, Math.min(1, (rx+lx)/2)); // invertir horizontal (mirar der ‚Üí x grande)
      const gyN = Math.max(0, Math.min(1, (ry+ly)/2));

      const r=stageEl.getBoundingClientRect();
      const rx0=roiNorm.x0*r.width, ry0=roiNorm.y0*r.height;
      const rw =(roiNorm.x1-roiNorm.x0)*r.width;
      const rh =(roiNorm.y1-roiNorm.y0)*r.height;

      const gx = rx0 + gxN*rw;
      const gy = ry0 + gyN*rh;

      // enviar al worker (Kalman+deadzone+step+snap se aplican de vuelta)
      if(kalmanReady){ kalmanWorker.postMessage({in:{x:gx, y:gy, W, H}}); }
    }

    // preview
    if(preview.style.display!=='none' && CFG.debug){
      pctx.clearRect(0,0,preview.width,preview.height);
      pctx.drawImage(rawVideo,0,0,preview.width,preview.height);
      const toPX = (p) => [p.x*preview.width, p.y*preview.height];
      const dot = (x,y,r=3,c='#0f0')=>{ pctx.fillStyle=c; pctx.beginPath(); pctx.arc(x,y,r,0,Math.PI*2); pctx.fill(); };
      IRIS_R.concat(IRIS_L,[13,14,61,291,33,263]).forEach(i=>{ const [x,y]=toPX(lm[i]); dot(x,y,3,'#0f0'); });
    }
  });

  // -------- WebGazer fallback (si no usamos iris) --------
  if(!CFG.useIris && CFG.controlMode==='eyes'){
    try{
      webgazer.setRegression('ridge'); webgazer.setTracker('TFFacemesh');
      if(webgazer.params){ webgazer.params.showVideoPreview=false; webgazer.params.showFaceFeedbackBox=false; webgazer.params.showPredictionPoints=false; }
      webgazer.begin();
      webgazer.setGazeListener((data)=>{ if(!data) return; const r=stageEl.getBoundingClientRect(); const gx=data.x - r.left, gy=data.y - r.top; if(kalmanReady){ kalmanWorker.postMessage({in:{x:gx,y:gy,W,H}}); } });
    }catch(e){ showErr('webgazer init: '+e.message); }
  }

  // -------- Cargar calibraci√≥n previa --------
  const saved = loadJson(LS_KEY); if(saved && saved.A && saved.b){ A=saved.A; b=saved.b; }

  // -------- bucle principal (nariz + boca + pintar) --------
  function loop(){
    // Nariz como control alternativo
    if(CFG.controlMode==='nose' && faceBox && nose.x!=null){
      const nxr = (nose.x - faceBox.minx)/Math.max(1e-6, (faceBox.maxx - faceBox.minx));
      const nyr = (nose.y - faceBox.miny)/Math.max(1e-6, (faceBox.maxy - faceBox.miny));
      const tx = nxr * W, ty = nyr * H;
      if(kalmanReady){ kalmanWorker.postMessage({in:{x:tx,y:ty,W,H}}); }
    }

    // gatillo de boca (histeresis)
    if(marEma!=null){
      const openThr  = mouthThr + CFG.mouthHys;
      const closeThr = mouthThr - CFG.mouthHys;
      isPainting = isPainting ? (marEma > closeThr) : (marEma > openThr);
    }

    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);
  requestAnimationFrame(faceLoop);

  // ======= recibir posici√≥n filtrada desde el worker y pintar / anclas / snap =======
  let filtX=null, filtY=null;
  function applyFiltered(x,y){
    // af√≠n solo para modo ojos (corrige drift global); nariz usa coords directas
    if(CFG.controlMode==='eyes'){
      const tx = A[0]*x + A[1]*y + b[0];
      const ty = A[2]*x + A[3]*y + b[1];
      filtX = Math.max(0, Math.min(W-1, tx));
      filtY = Math.max(0, Math.min(H-1, ty));
    }else{
      filtX = Math.max(0, Math.min(W-1, x));
      filtY = Math.max(0, Math.min(H-1, y));
    }

    // auto-aim snap a grilla
    if(CFG.snap?.enabled){
      const s = snapToGrid(filtX, filtY, CFG.snap.size, CFG.snap.radius, CFG.snap.blend);
      filtX = s.x; filtY = s.y;
    }

    // anclas anti-drift (solo ojos)
    if(anchorsOn && CFG.controlMode==='eyes') applyAnchors();

    // cursor y trazo
    if(mode!=='face'){
      cursor.style.display='block';
      cursor.style.left=filtX+'px'; cursor.style.top=filtY+'px';
      cursor.style.width=(brush*2)+'px'; cursor.style.height=(brush*2)+'px';
    } else { cursor.style.display='none'; }

    if(mode==='brush' && isPainting){
      if(last){
        ctx.strokeStyle='rgba(0,200,255,.95)'; ctx.lineWidth=brush; ctx.lineJoin='round'; ctx.lineCap='round';
        const cxm=(last.x+filtX)/2, cym=(last.y+filtY)/2;
        ctx.beginPath(); ctx.moveTo(last.x,last.y); ctx.quadraticCurveTo(cxm,cym,filtX,filtY); ctx.stroke();
        pts.push({t:Date.now(), x:filtX, y:filtY, mar:marEma});
        countEl.textContent = `pts: ${pts.length}`;
      }
      last = {x:filtX,y:filtY};
    }else{
      last = {x:filtX,y:filtY};
    }
  }

  // --------- ROI + Calibraci√≥n GUI ---------
  function defineRoiWithMouse(){
    alert('Arrastra con el mouse para dibujar la zona (ROI) donde mirar√°s con los ojos.');
    const r=stageEl.getBoundingClientRect();
    let start=null, rectEl=null;

    function onDown(e){
      start={x:e.clientX - r.left, y:e.clientY - r.top};
      if(!rectEl){ rectEl=document.createElement('div'); rectEl.className='roi-rect'; roiOverlay.appendChild(rectEl); }
      placeRect(start.x,start.y,1,1);
      window.addEventListener('mousemove',onMove);
      window.addEventListener('mouseup',onUp,{once:true});
    }
    function onMove(e){
      const x=e.clientX - r.left, y=e.clientY - r.top;
      const x0=Math.min(start.x,x), y0=Math.min(start.y,y);
      const x1=Math.max(start.x,x), y1=Math.max(start.y,y);
      placeRect(x0,y0, x1-x0, y1-y0);
    }
    function onUp(e){
      window.removeEventListener('mousemove',onMove);
      const bb=rectEl.getBoundingClientRect();
      const x0=(bb.left - r.left)/r.width, y0=(bb.top - r.top)/r.height;
      const x1=(bb.right - r.left)/r.width, y1=(bb.bottom - r.top)/r.height;
      roiNorm = {x0:clamp01(x0), y0:clamp01(y0), x1:clamp01(x1), y1:clamp01(y1)};
      saveJson(ROI_KEY, roiNorm); drawRoiRect();
      alert('ROI guardada. Ejecuta la calibraci√≥n guiada para afinar la af√≠n.');
    }
    stageEl.addEventListener('mousedown',onDown,{once:true});
    function placeRect(x,y,w,h){ const el=roiOverlay.lastChild; el.style.left=x+'px'; el.style.top=y+'px'; el.style.width=w+'px'; el.style.height=h+'px'; }
  }
  function drawRoiRect(){
    roiOverlay.innerHTML='';
    const r=stageEl.getBoundingClientRect();
    const x0=roiNorm.x0*r.width, y0=roiNorm.y0*r.height;
    const w =(roiNorm.x1-roiNorm.x0)*r.width;
    const h =(roiNorm.y1-roiNorm.y0)*r.height;
    const rectEl=document.createElement('div');
    rectEl.className='roi-rect';
    rectEl.style.left=x0+'px'; rectEl.style.top=y0+'px';
    rectEl.style.width=w+'px'; rectEl.style.height=h+'px';
    roiOverlay.appendChild(rectEl);
  }

  async function guidedRoiCalibration(){
    if(CFG.controlMode!=='eyes'){ alert('La calibraci√≥n aplica al control por OJOS. Cambia ‚ÄúMover brocha con‚Äù a OJOS.'); return; }
    const r=stageEl.getBoundingClientRect();
    const rx0=roiNorm.x0*r.width, ry0=roiNorm.y0*r.height;
    const rw =(roiNorm.x1-roiNorm.x0)*r.width;
    const rh =(roiNorm.y1-roiNorm.y0)*r.height;

    const nx=[0,0.5,1], ny=[0,0.5,1];
    const targets=[]; for(const ix of nx) for(const iy of ny){ targets.push({ x: rx0 + ix*rw, y: ry0 + iy*rh }); }

    roiOverlay.innerHTML=''; drawRoiRect();
    const els=[];
    for(const t of targets){
      const el=document.createElement('div'); el.className='calib-target wait';
      el.style.left=t.x+'px'; el.style.top=t.y+'px';
      roiOverlay.appendChild(el); els.push(el);
    }

    alert('Calibraci√≥n: clic en cada punto y MIRA ese punto ~1.2s.');
    const gazePts=[], tgtPts=[];
    for(let i=0;i<targets.length;i++){
      const el=els[i]; const t=targets[i];
      await new Promise(res=>{
        const onceClick = async ()=>{
          el.classList.remove('wait'); el.classList.add('calib-target');
          const samples=[]; const t0=performance.now();
          function step(){
            const now=performance.now(); if(gaze.x!=null&&gaze.y!=null){
              samples.push([gaze.x - r.left, gaze.y - r.top]);
            }
            if(now-t0<1200){ requestAnimationFrame(step); }
            else{
              const m=mean2(samples);
              if(!isNaN(m[0])){ gazePts.push(m); tgtPts.push([t.x, t.y]); }
              el.classList.add('done'); res();
            }
          }
          requestAnimationFrame(step);
        };
        el.addEventListener('click', onceClick, {once:true});
      });
      await sleep(120);
    }
    const sol=lsqAffine(gazePts, tgtPts); if(sol){A=sol.A; b=sol.b; saveJson(LS_KEY,{A,b}); alert('‚úÖ Calibraci√≥n af√≠n guardada.');}
    else alert('No se pudo calibrar (muestras insuficientes).');
  }

  // ---------- Anclas anti-drift ----------
  function getAnchors(){
    const r=stageEl.getBoundingClientRect();
    const rx0=roiNorm.x0*r.width, ry0=roiNorm.y0*r.height;
    const rw =(roiNorm.x1-roiNorm.x0)*r.width;
    const rh =(roiNorm.y1-roiNorm.y0)*r.height;
    return [
      {x:rx0,        y:ry0       }, // TL
      {x:rx0+rw,     y:ry0       }, // TR
      {x:rx0+rw,     y:ry0+rh    }, // BR
      {x:rx0,        y:ry0+rh    }, // BL
      {x:rx0+rw/2,   y:ry0+rh/2  }  // C
    ];
  }
  function applyAnchors(){
    if(filtX==null||filtY==null) return;
    const APTS = getAnchors();
    let best=null, bd=1e9;
    for(const p of APTS){ const d=Math.hypot(p.x-filtX,p.y-filtY); if(d<bd){bd=d; best=p;} }
    if(bd <= CFG.anchors.radiusPx){
      if(currentAnchor!==best){ currentAnchor=best; dwellStart=performance.now(); }
      else{
        const dt=performance.now()-dwellStart;
        if(dt >= CFG.anchors.dwellMs){
          // corrige solo traslaci√≥n (b), peque√±o paso
          const errX = best.x - (A[0]*filtX + A[1]*filtY + b[0]);
          const errY = best.y - (A[2]*filtX + A[3]*filtY + b[1]);
          b[0] += errX * CFG.anchors.adjust;
          b[1] += errY * CFG.anchors.adjust;
          saveJson(LS_KEY,{A,b});
          dwellStart = performance.now(); // evita over-correcci√≥n
        }
      }
    }else{
      currentAnchor=null; dwellStart=null;
    }
  }

  // ---------- Snap (auto-aim) ----------
  function snapToGrid(x,y,G,R,B){
    const gx = Math.round(x/G)*G, gy = Math.round(y/G)*G;
    const d = Math.hypot(gx-x, gy-y);
    if(d<=R){ return {x: (1-B)*x + B*gx, y:(1-B)*y + B*gy}; }
    return {x,y};
  }

  // ---------- utils y √°lgebra ----------
  function sleep(ms){return new Promise(r=>setTimeout(r,ms));}
  function mean2(a){if(!a.length)return[NaN,NaN];const sx=a.reduce((s,v)=>s+v[0],0), sy=a.reduce((s,v)=>s+v[1],0);return[sx/a.length, sy/a.length];}
  function median(arr){ if(!arr.length) return NaN; const a=[...arr].sort((x,y)=>x-y), m=Math.floor(a.length/2); return a.length%2 ? a[m] : (a[m-1]+a[m])/2; }
  function clamp01(v){return Math.max(0,Math.min(1,v));}
  function transpose(A){const m=A.length,n=A[0].length,AT=Array.from({length:n},()=>Array(m).fill(0));for(let i=0;i<m;i++)for(let j=0;j<n;j++)AT[j][i]=A[i][j];return AT;}
  function mul(A,B){const m=A.length,n=A[0].length,p=B[0].length,C=Array.from({length:m},()=>Array(p).fill(0));for(let i=0;i<m;i++)for(let k=0;k<n;k++)for(let j=0;j<p;j++)C[i][j]+=A[i][k]*B[k][j];return C;}
  function mulVec(A,v){const m=A.length,n=A[0].length,r=Array(m).fill(0);for(let i=0;i<m;i++)for(let j=0;j<n;j++)r[i]+=A[i][j]*v[j];return r;}
  function solveGaussian(A,b){const n=A.length,M=A.map((row,i)=>row.concat([b[i]]));for(let i=0;i<n;i++){let max=i;for(let r=i+1;r<n;r++)if(Math.abs(M[r][i])>Math.abs(M[max][i]))max=r;if(Math.abs(M[max][i])<1e-9)return null;[M[i],M[max]]=[M[max],M[i]];const piv=M[i][i];for(let k=i;k<=n;k++)M[i][k]/=piv;for(let r=0;r<n;r++)if(r!==i){const f=M[r][i];for(let k=i;k<=n;k++)M[r][k]-=f*M[i][k];}}return M.map(row=>row[n]);}
  function lsqAffine(gPts,tPts){
    if(!gPts.length || gPts.length<3) return null;
    const M=[],Z=[];
    for(let i=0;i<gPts.length;i++){
      const[gx,gy]=gPts[i]; const[tx,ty]=tPts[i];
      M.push([gx,gy,0,0,1,0]); Z.push(tx);
      M.push([0,0,gx,gy,0,1]); Z.push(ty);
    }
    const Mt=transpose(M),MtM=mul(Mt,M),MtZ=mulVec(Mt,Z),p=solveGaussian(MtM,MtZ);
    return p?{A:[p[0],p[1],p[2],p[3]],b:[p[4],p[5]]}:null;
  }
  function saveJson(k,v){ try{ localStorage.setItem(k, JSON.stringify(v)); }catch(e){} }
  function loadJson(k){ try{ const s=localStorage.getItem(k); return s?JSON.parse(s):null; }catch(e){ return null; } }

  // ---------- Worker Kalman (blob) ----------
  function makeKalmanWorker(){
    const code = `
      let ready=false, cfg={procNoise:1e-2, measNoise:2.0, maxStep:22, deadzone:6};
      // Kalman sencillo 2D (pos+vel)
      class Kal2D{
        constructor(q=1e-2,r=2.0,dt=1/60){
          this.dt=dt; this.q=q; this.r=r;
          this.x = [0,0,0,0]; // [x,y,vx,vy]
          this.P = [1,0,0,0, 0,1,0,0, 0,0,10,0, 0,0,0,10];
          this.H = [1,0,0,0, 0,1,0,0];
          this.R = [r,0, 0,r];
        }
        predict(){
          const dt=this.dt;
          // x_k = F x_{k-1}
          const F=[1,0,dt,0, 0,1,0,dt, 0,0,1,0, 0,0,0,1];
          this.x = [
            F[0]*this.x[0]+F[2]*this.x[2],
            F[5]*this.x[1]+F[7]*this.x[3],
            this.x[2], this.x[3]
          ];
          // P = F P F^T + Q
          const Q=[cfg.procNoise,0,0,0, 0,cfg.procNoise,0,0, 0,0,1e-3,0, 0,0,0,1e-3];
          const P=this.P;
          // P' = FPF^T (manual r√°pido)
          const FP = new Array(16).fill(0);
          for(let i=0;i<4;i++)for(let j=0;j<4;j++)for(let k=0;k<4;k++) FP[i*4+j]+=F[i*4+k]*P[k*4+j];
          const FPt = new Array(16).fill(0);
          for(let i=0;i<4;i++)for(let j=0;j<4;j++)for(let k=0;k<4;k++) FPt[i*4+j]+=FP[i*4+k]*F[j*4+k]; // F^T by index trick
          for(let i=0;i<16;i++) this.P = FPt[i]+Q[i];
          this.P = FPt.map((v,i)=>v+Q[i]);
        }
        update(zx,zy){
          // y = z - Hx
          const yx = zx - (this.H[0]*this.x[0]+this.H[1]*this.x[1]);
          const yy = zy - (this.H[4]*this.x[0]+this.H[5]*this.x[1]);
          // S = HPH^T + R
          const P=this.P; const H=this.H; const R=this.R;
          const S00 = H[0]*P[0]*H[0]+H[1]*P[4]*H[0] + R[0];
          const S11 = H[4]*P[1]*H[5]+H[5]*P[5]*H[5] + R[3];
          const S01 = H[0]*P[1]*H[5]+H[1]*P[5]*H[5];
          const det = S00*S11 - S01*S01;
          if(Math.abs(det)<1e-9) return;
          const iS00 =  S11/det, iS11 = S00/det, iS01 = -S01/det;
          // K = P H^T S^{-1}
          const K0 = P[0]*H[0]*iS00 + P[1]*H[5]*iS01;
          const K1 = P[4]*H[0]*iS00 + P[5]*H[5]*iS01;
          const K2 = P[8]*H[0]*iS00 + P[9]*H[5]*iS01;
          const K3 = P[12]*H[0]*iS00 + P[13]*H[5]*iS01;
          const Ky0 = P[1]*H[0]*iS01 + P[5]*H[5]*iS11; // not used explicitly (compact form)
          // update x
          this.x[0]+=K0*yx; this.x[1]+=K1*yy;
          // (vel update omitted for brevity)
        }
      }
      const kf = new Kal2D();
      self.postMessage({ready:true});
      self.onmessage = (e)=>{
        if(e.data?.cfg){ cfg = Object.assign(cfg, e.data.cfg); return; }
        if(e.data?.in){
          const {x,y,W,H} = e.data.in;
          // deadzone contra jitter
          // (aplicamos en la salida, por simplicidad)
          kf.predict(); kf.update(x,y);
          let ox = kf.x[0], oy = kf.x[1];
          // clamp paso m√°ximo
          // (para simplicidad asumimos que llega a tasa estable)
          // (puedes mover este clamp a main si prefieres)
          self.postMessage({out:{x:ox, y:oy}});
        }
      };
    `;
    const blob = new Blob([code], {type:'application/javascript'});
    const url = URL.createObjectURL(blob);
    return new Worker(url);
  }

})();
</script>
</body>
</html>
