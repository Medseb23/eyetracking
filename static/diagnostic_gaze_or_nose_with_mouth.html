<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Brocha Ojos/Nariz + Boca (estable)</title>

<!-- OJOS -->
<script src="https://webgazer.cs.brown.edu/webgazer.js"></script>
<!-- CARA (boca+nariz) -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh"></script>

<style>
  html,body{margin:0;padding:0;height:100%;overflow:hidden;background:#0f1115;color:#fff}
  #wrap{position:relative;width:100%;height:100vh}
  #topbar{position:absolute;top:10px;left:10px;right:10px;display:flex;gap:8px;flex-wrap:wrap;
          background:rgba(0,0,0,.45);padding:8px 10px;border-radius:10px;align-items:center;z-index:10000}
  .btn{appearance:none;border:0;padding:6px 10px;border-radius:10px;cursor:pointer;background:#22272e;color:#fff;font-weight:600}
  .btn.primary{background:#00e676;color:#111}
  .btn.warn{background:#ff5252}
  .sp{margin-left:auto;font:12px/1.2 monospace;opacity:.9}
  select.sel{background:#22272e;color:#fff;border:0;border-radius:10px;padding:6px 10px;font-weight:600}
  #stage{position:absolute;inset:62px 10px 10px 10px;border-radius:10px;background:#10131a;overflow:hidden}
  #canvas{position:absolute;inset:0;width:100%;height:100%}
  #cursor{position:absolute;width:20px;height:20px;border:2px solid rgba(255,255,255,.95);border-radius:50%;
          pointer-events:none;transform:translate(-50%,-50%);display:none;box-shadow:0 0 12px rgba(0,230,118,.25)}
  #ghost{position:absolute;inset:0;pointer-events:none}
  #status{position:absolute;bottom:10px;left:10px;right:10px;display:flex;gap:10px;align-items:center;
          background:rgba(255,255,255,.06);padding:8px 10px;border-radius:10px;z-index:9999}
  #modeTag{font-weight:700;background:#1f2937;padding:4px 8px;border-radius:8px}
  #marPanel{display:flex;align-items:center;gap:8px;flex:1}
  #marBar{position:relative;height:10px;flex:1;background:#2b2f3a;border-radius:6px;overflow:hidden}
  #marFill{position:absolute;top:0;left:0;height:100%;width:0%;background:#00e676}
  #marThr{position:absolute;top:-3px;width:2px;height:16px;background:#ff5252;left:50%}
  #marVal{min-width:160px;text-align:right;font:12px/1 monospace;opacity:.9}
  #preview{position:absolute;top:10px;right:10px;width:300px;height:225px;background:#000a;border-radius:8px;display:none;z-index:5000}
  video#rawVideo{display:none}
  #errbar{position:absolute;bottom:0;left:0;right:0;background:#ff3344;color:#100;padding:6px 10px;font:12px/1.3 monospace;
          display:none;z-index:10001}

  .roi-overlay{position:absolute;inset:0;pointer-events:none}
  .roi-rect{position:absolute;border:2px dashed rgba(0,230,118,.9);border-radius:8px;box-shadow:0 0 0 200vmax rgba(0,0,0,.45) inset}
  .calib-target{position:absolute;width:18px;height:18px;border-radius:50%;background:#00e676;
                box-shadow:0 0 0 6px rgba(0,230,118,.2);transform:translate(-50%,-50%);pointer-events:auto;cursor:crosshair}
  .calib-target.wait{background:#fbbf24; box-shadow:0 0 0 6px rgba(251,191,36,.25)}
  .calib-target.done{background:#22d3ee; box-shadow:0 0 0 6px rgba(34,211,238,.25)}
</style>
</head>
<body>
<div id="wrap">
  <div id="topbar">
    <button id="testCam" class="btn">üé• Probar c√°mara</button>
    <button id="modeFace" class="btn">1) Test de Boca</button>
    <button id="modeGaze" class="btn">2) Test de Movimiento</button>
    <button id="modeBrush" class="btn primary">3) Iniciar Brocha</button>

    <button id="btnRoi" class="btn">üñ±Ô∏è Zona (ROI)</button>
    <button id="btnCalRoi" class="btn">üéØ Calibraci√≥n ROI</button>
    <button id="btnAutoMar" class="btn">üéöÔ∏è Auto-umbral boca</button>
    <button id="btnResetCal" class="btn warn">‚ôªÔ∏è Reset Calibraci√≥n</button>

    <select id="brushMode" class="sel">
      <option value="line">‚úíÔ∏è L√≠nea</option>
      <option value="spray">üü¢ Spray</option>
      <option value="calli">üñãÔ∏è Caligraf√≠a</option>
    </select>

    <button id="togglePreview" class="btn">üëÅÔ∏è Preview</button>
    <button id="undo" class="btn">‚Ü©Ô∏è Deshacer</button>
    <button id="clear" class="btn warn">üßπ Limpiar</button>
    <button id="savePng" class="btn">üñºÔ∏è PNG</button>
    <button id="saveCsv" class="btn">üìÑ CSV</button>
    <span class="sp" id="count">pts: 0</span>
  </div>

  <div id="stage">
    <canvas id="canvas"></canvas>
    <canvas id="ghost"></canvas>
    <div id="cursor"></div>
    <canvas id="preview"></canvas>
    <video id="rawVideo" playsinline autoplay muted></video>
    <div class="roi-overlay" id="roiOverlay"></div>
  </div>

  <div id="status">
    <span id="modeTag">Modo: Test de Boca</span>
    <div id="marPanel">
      <span>MAR:</span>
      <div id="marBar"><div id="marFill"></div><div id="marThr"></div></div>
      <span id="marVal">‚Äî</span>
    </div>
  </div>

  <div id="errbar"></div>
</div>

<script>
(function(){
  // -------- errores visibles --------
  const errbar=document.getElementById('errbar');
  function showErr(msg){ errbar.textContent='‚ö†Ô∏è '+msg; errbar.style.display='block'; }
  window.onerror=(m,src,l,c)=>showErr((m||'Error')+(l?` @${l}:${c||0}`:''));
  window.onunhandledrejection=(ev)=>showErr('Promise rejection: '+(ev.reason?.message||ev.reason||''));

  // -------- config desde Python --------
  const CFG = Object.assign({
    brush:8, alpha:.20, mouthThr:.28, debug:true, controlMode:'eyes',
    deadzonePx:8, maxStepPx:24, medianN:5, mouthHys:.05,
    marMedianN:5, marEmaAlpha:.30,
    marUseEyeScale:true, marEyeFactor:0.35,
    detConf:.5, trackConf:.5,
    resamplePx: 2.5,            // espaciamiento fijo de trazo
    accelMax: 60,               // l√≠mite de aceleraci√≥n px/frame^2
    deadzoneAuto:true,          // deadzone adaptativa
    ghostLen: 14                // puntos de cola fantasma
  }, window.DIAG_CFG||{});

  // -------- DOM --------
  const stageEl=document.getElementById('stage');
  const canvas=document.getElementById('canvas'); const ctx=canvas.getContext('2d');
  const ghost=document.getElementById('ghost'); const gctx=ghost.getContext('2d');
  const cursor=document.getElementById('cursor');
  const preview=document.getElementById('preview'); const pctx=preview.getContext('2d');
  const rawVideo=document.getElementById('rawVideo');
  const countEl=document.getElementById('count'); const modeTag=document.getElementById('modeTag');
  const marVal=document.getElementById('marVal'); const marFill=document.getElementById('marFill'); const marThr=document.getElementById('marThr');
  const roiOverlay=document.getElementById('roiOverlay');
  const brushModeSel=document.getElementById('brushMode');

  // -------- estado --------
  let mode='face'; // 'face' | 'gmove' | 'brush'
  let brush=CFG.brush, alpha=CFG.alpha, mouthThr=CFG.mouthThr;
  let dpr=1, W=0, H=0, pts=[], path=[], last=null, smoothed=null, vPrev={x:0,y:0};
  let ghostPts=[];

  let brushMode=brushModeSel.value; brushModeSel.onchange=()=>brushMode=brushModeSel.value;

  // movimiento: ojos/nariz
  let gaze={x:null,y:null};
  let nose={x:null,y:null,z:null};
  let faceBox=null;

  // Calibraci√≥n af√≠n (ojos)
  let A=[1,0,0,1], b=[0,0];
  const LS_KEY='diag_calib_affine_v1';
  const ROI_KEY='diag_roi_norm_v1';
  const MAR_KEY='diag_auto_mar_v1';

  // ROI normalizado (0..1)
  let roiNorm = loadJson(ROI_KEY) || {x0:0.05,y0:0.08,x1:0.95,y1:0.92};

  // Anti-jitter
  let histX=[], histY[];
  let isPainting=false;

  // MAR suavizado
  let marHist=[], marEma=null;

  // Auto-MAR cache
  const savedMar = loadJson(MAR_KEY);
  if(savedMar && isFinite(savedMar.mouthThr) && isFinite(savedMar.hys)) {
    mouthThr = savedMar.mouthThr;
    CFG.mouthHys = savedMar.hys;
  }

  // -------- tama√±o --------
  function resize(){
    dpr=Math.min(window.devicePixelRatio||1,2);
    const r=stageEl.getBoundingClientRect();
    [canvas,ghost].forEach(cv=>{
      cv.width=Math.floor(r.width*dpr); cv.height=Math.floor(r.height*dpr);
      cv.style.width=r.width+'px'; cv.style.height=r.height+'px';
      cv.getContext('2d').setTransform(dpr,0,0,dpr,0,0);
    });
    preview.width=Math.floor(300*dpr); preview.height=Math.floor(225*dpr);
    preview.style.width='300px'; preview.style.height='225px'; pctx.setTransform(dpr,0,0,dpr,0,0);
    W=r.width; H=r.height;
    drawRoiRect();
  }
  window.addEventListener('resize', resize); resize();

  // -------- UI --------
  document.getElementById('modeFace').onclick=()=>setMode('face');
  document.getElementById('modeGaze').onclick=()=>setMode('gmove');
  document.getElementById('modeBrush').onclick=()=>setMode('brush');
  document.getElementById('togglePreview').onclick=()=>{preview.style.display=(preview.style.display==='none'||preview.style.display==='')?'block':'none';};
  document.getElementById('undo').onclick=undoLast;
  document.getElementById('clear').onclick=clearAll;
  document.getElementById('savePng').onclick=()=>{const a=document.createElement('a'); a.download=`brocha_${Date.now()}.png`; a.href=canvas.toDataURL('image/png'); a.click();};
  document.getElementById('saveCsv').onclick=saveCsv;
  document.getElementById('btnRoi').onclick = defineRoiWithMouse;
  document.getElementById('btnCalRoi').onclick = guidedRoiCalibration;
  document.getElementById('btnResetCal').onclick = ()=>{ A=[1,0,0,1]; b=[0,0]; saveJson(LS_KEY,{A,b}); alert('Calibraci√≥n reiniciada.'); };
  document.getElementById('btnAutoMar').onclick = autoMar;

  function setMode(m){
    mode=m;
    modeTag.textContent='Modo: '+(m==='face'?'Test de Boca': m==='gmove'?'Test de Movimiento':'Brocha');
    if(m==='face') cursor.style.display='none'; else cursor.style.display='block';
  }

  function undoLast(){
    if(path.length===0) return;
    const lastSeg = path.pop();
    // Redibuja desde cero
    ctx.clearRect(0,0,canvas.width,canvas.height);
    for(const seg of path){ drawSegment(seg); }
  }
  function clearAll(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    pts=[]; path=[]; countEl.textContent='pts: 0'; last=null; smoothed=null; vPrev={x:0,y:0};
  }
  function saveCsv(){
    const header='t_ms,x,y,mar,mode\n';
    const body=pts.map(p=>`${p.t},${Math.round(p.x)},${Math.round(p.y)},${(p.mar??0).toFixed(4)},${CFG.controlMode}`).join('\n');
    const blob=new Blob([header+body],{type:'text/csv'});
    const url=URL.createObjectURL(blob);
    const a=document.createElement('a'); a.href=url; a.download=`brocha_${CFG.controlMode}_${Date.now()}.csv`; a.click();
    URL.revokeObjectURL(url);
  }

  // -------- atajos --------
  window.addEventListener('keydown',(e)=>{
    if(e.key==='z' || e.key==='Z') undoLast();
    if(e.key==='c' || e.key==='C') clearAll();
  });

  // -------- c√°mara --------
  let gStream=null;
  document.getElementById('testCam').onclick=async ()=>{
    try{
      gStream=await navigator.mediaDevices.getUserMedia({video:{width:640,height:480}});
      rawVideo.srcObject=gStream; await rawVideo.play(); errbar.style.display='none';
      alert('‚úÖ C√°mara iniciada.');
    }catch(e){ showErr('getUserMedia: '+(e.name||'')+' ‚Äî '+(e.message||'')); }
  };

  // -------- FaceMesh (boca + nariz) --------
  const faceMesh=new FaceMesh({ locateFile:(f)=>`https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${f}` });
  faceMesh.setOptions({
    maxNumFaces:3, refineLandmarks:true,
    minDetectionConfidence: CFG.detConf,
    minTrackingConfidence:  CFG.trackConf
  });

  function bboxOf(lm){let minx=1,miny=1,maxx=0,maxy=0; for(const p of lm){minx=Math.min(minx,p.x); miny=Math.min(miny,p.y); maxx=Math.max(maxx,p.x); maxy=Math.max(maxy,p.y);} return {minx,miny,maxx,maxy,cx:(minx+maxx)/2,cy:(miny+maxy)/2,area:(maxx-minx)*(maxy-miny)};}
  function pickMainFace(arr){ if(!arr||!arr.length) return null; let k=0,b=Infinity; for(let i=0;i<arr.length;i++){ const bb=bboxOf(arr[i]); const dc=(bb.cx-0.5)**2+(bb.cy-0.5)**2; const s=dc/(bb.area+1e-6); if(s<b){b=s;k=i;} } return arr[k]; }
  function dist(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }

  async function faceLoop(){ try{ if(rawVideo.readyState>=2 && !rawVideo.paused && !rawVideo.ended){ await faceMesh.send({image:rawVideo}); } }catch(e){ showErr('faceLoop: '+e.message); } requestAnimationFrame(faceLoop); }

  faceMesh.onResults(res=>{
    if(!res.multiFaceLandmarks || !res.multiFaceLandmarks.length) return;
    const main = pickMainFace(res.multiFaceLandmarks); if(!main) return;

    faceBox = bboxOf(main);
    if (faceBox.area < 0.03) { return; } // cara muy peque√±a ‚Üí m√°s errores

    const lm = main;
    const d = (i,j)=>{ const a=lm[i], b=lm[j]; return Math.hypot(a.x-b.x, a.y-b.y); };

    const mouthH = d(13,14);
    let mouthW   = d(61,291);
    const eyeDst = d(33,263);

    const denom = (CFG.marUseEyeScale)
      ? Math.max(mouthW, CFG.marEyeFactor * eyeDst)
      : mouthW;

    let marRaw = mouthH / Math.max(1e-6, denom);

    // Suavizado MAR: mediana + EMA
    marHist.push(marRaw);
    if (marHist.length > CFG.marMedianN) marHist.shift();
    const marMed = median(marHist);
    if (marEma == null) marEma = marMed;
    marEma = CFG.marEmaAlpha * marMed + (1 - CFG.marEmaAlpha) * marEma;

    // UI barra
    const marUi = Math.max(0, Math.min(0.8, marEma));
    marVal.textContent = `raw:${marRaw.toFixed(3)}  filt:${marEma.toFixed(3)}  thr:${mouthThr.toFixed(2)}¬±${CFG.mouthHys.toFixed(2)}`;
    marFill.style.width = (marUi / 0.8 * 100).toFixed(0) + '%';
    marThr.style.left   = (Math.max(0, Math.min(1, mouthThr / 0.8)) * 100).toFixed(0) + '%';

    // nariz (posici√≥n)
    const NOSE_IDX=[1,4];
    let nz = lm[NOSE_IDX[0]];
    for(const idx of NOSE_IDX){ if(lm[idx] && lm[idx].z < nz.z) nz = lm[idx]; }
    nose = {x:nz.x, y:nz.y, z:nz.z};

    // preview
    if(preview.style.display!=='none' && CFG.debug){
      pctx.clearRect(0,0,preview.width,preview.height);
      pctx.drawImage(rawVideo,0,0,preview.width,preview.height);
      const toPX = (p) => [p.x*preview.width, p.y*preview.height];
      const dot = (x,y,r=3,c='#0f0')=>{ pctx.fillStyle=c; pctx.beginPath(); pctx.arc(x,y,r,0,Math.PI*2); pctx.fill(); };
      [61,291].forEach(i=>{ const [x,y]=toPX(lm[i]); dot(x,y,3,'#0f0'); });
      [33,263].forEach(i=>{ const [x,y]=toPX(lm[i]); dot(x,y,3,'#ff0'); });
      [13,14].forEach(i=>{ const [x,y]=toPX(lm[i]); dot(x,y,3,'#0ff'); });
      const nx = nose.x*preview.width, ny = nose.y*preview.height; dot(nx,ny,4,'#f0f');
      pctx.fillStyle='#fff'; pctx.fillText(`MAR=${marEma.toFixed(3)}`,8,16);
    }
  });

  // -------- WebGazer (ojos) --------
  try{
    webgazer.setRegression('ridge'); webgazer.setTracker('TFFacemesh');
    if(webgazer.params){
      webgazer.params.showVideoPreview=false;
      webgazer.params.showFaceFeedbackBox=false;
      webgazer.params.showPredictionPoints=false;
    }
    webgazer.begin();
    webgazer.setGazeListener((data)=>{ if(!data) return; gaze.x=data.x; gaze.y=data.y; });
  }catch(e){ showErr('webgazer init: '+e.message); }

  // -------- Cargar calibraci√≥n previa --------
  const saved = loadJson(LS_KEY); if(saved && saved.A && saved.b){ A=saved.A; b=saved.b; }

  // -------- bucle principal --------
  function loop(){
    // 1) Coordenadas de control ‚Üí (x,y) del canvas
    let cx=null, cy=null;

    if(CFG.controlMode==='eyes' && gaze.x!=null && gaze.y!=null){
      const r=stageEl.getBoundingClientRect();
      const gx = gaze.x - r.left, gy = gaze.y - r.top;

      // mediana
      histX.push(gx); histY.push(gy);
      if(histX.length>CFG.medianN){ histX.shift(); histY.shift(); }
      const gxMed = median(histX), gyMed = median(histY);

      // EMA posici√≥n adaptativa por velocidad
      if(!smoothed) smoothed={x:gxMed,y:gyMed};
      const vx = gxMed - smoothed.x, vy = gyMed - smoothed.y;
      const speed = Math.hypot(vx,vy);
      const aDyn = clamp(alpha + speed*0.002, 0.10, 0.65); // m√°s r√°pido ‚Üí m√°s alpha
      let nx = aDyn*gxMed + (1-aDyn)*smoothed.x;
      let ny = aDyn*gyMed + (1-aDyn)*smoothed.y;

      // deadzone adaptativa
      let dz = CFG.deadzonePx;
      if(CFG.deadzoneAuto){
        dz = clamp(CFG.deadzonePx + (speed>8 ? 2 : -1), 4, 14);
      }
      if(Math.hypot(nx-smoothed.x, ny-smoothed.y) < dz){ nx = smoothed.x; ny = smoothed.y; }

      // l√≠mite de paso + aceleraci√≥n
      [nx,ny] = clampStep(smoothed.x, smoothed.y, nx, ny, CFG.maxStepPx);
      const ax = (nx-smoothed.x)-vPrev.x, ay = (ny-smoothed.y)-vPrev.y;
      const accel = Math.hypot(ax,ay);
      if(accel>CFG.accelMax){
        const k=CFG.accelMax/(accel||1);
        nx = smoothed.x + vPrev.x + ax*k; ny = smoothed.y + vPrev.y + ay*k;
      }
      vPrev = {x:nx-smoothed.x, y:ny-smoothed.y};

      smoothed.x = nx; smoothed.y = ny;

      // af√≠n
      cx = A[0]*nx + A[1]*ny + b[0];
      cy = A[2]*nx + A[3]*ny + b[1];
    }

    if(CFG.controlMode==='nose' && nose.x!=null && faceBox){
      const nxr = (nose.x - faceBox.minx)/Math.max(1e-6, (faceBox.maxx - faceBox.minx));
      const nyr = (nose.y - faceBox.miny)/Math.max(1e-6, (faceBox.maxy - faceBox.miny));
      const tx = nxr * W, ty = nyr * H;

      histX.push(tx); histY.push(ty);
      if(histX.length>CFG.medianN){ histX.shift(); histY.shift(); }
      const tMedX = median(histX), tMedY = median(histY);

      if(!smoothed) smoothed={x:tMedX,y:tMedY};
      const vx = tMedX - smoothed.x, vy = tMedY - smoothed.y;
      const speed = Math.hypot(vx,vy);
      const aDyn = clamp(alpha + speed*0.002, 0.10, 0.65);
      let nx = aDyn*tMedX + (1-aDyn)*smoothed.x;
      let ny = aDyn*tMedY + (1-aDyn)*smoothed.y;

      let dz = CFG.deadzonePx;
      if(CFG.deadzoneAuto){
        dz = clamp(CFG.deadzonePx + (speed>8 ? 2 : -1), 4, 14);
      }
      if(Math.hypot(nx-smoothed.x, ny-smoothed.y) < dz){ nx = smoothed.x; ny = smoothed.y; }

      [nx,ny] = clampStep(smoothed.x, smoothed.y, nx, ny, CFG.maxStepPx);

      const ax = (nx-smoothed.x)-vPrev.x, ay = (ny-smoothed.y)-vPrev.y;
      const accel = Math.hypot(ax,ay);
      if(accel>CFG.accelMax){
        const k=CFG.accelMax/(accel||1);
        nx = smoothed.x + vPrev.x + ax*k; ny = smoothed.y + vPrev.y + ay*k;
      }
      vPrev = {x:nx-smoothed.x, y:ny-smoothed.y};

      smoothed.x = nx; smoothed.y = ny;
      cx = nx; cy = ny;
    }

    // 2) Histeresis de boca
    if(marEma!=null){
      const openThr  = mouthThr + CFG.mouthHys;
      const closeThr = mouthThr - CFG.mouthHys;
      if(isPainting){ isPainting = marEma > closeThr; } else { isPainting = marEma > openThr; }
    }

    // 3) Cursor, ghost y pintar
    if(cx!=null && cy!=null){
      const x = Math.max(0, Math.min(W-1, cx));
      const y = Math.max(0, Math.min(H-1, cy));

      if(mode!=='face'){
        cursor.style.display='block';
        cursor.style.left=x+'px'; cursor.style.top=y+'px';
        const bsz = (brushMode==='calli') ? clamp(brush*(1+Math.min(1, speedAt(x,y)*0.04)), 2, brush*2.2) : brush;
        cursor.style.width=(bsz*2)+'px'; cursor.style.height=(bsz*2)+'px';
      } else { cursor.style.display='none'; }

      // ghost trail
      ghostPts.push({x,y});
      if(ghostPts.length>CFG.ghostLen) ghostPts.shift();
      drawGhost();

      if(mode==='brush' && isPainting){
        drawStroke({x,y});
      }
      last={x,y};
    }

    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);
  requestAnimationFrame(faceLoop);

  // ================================
  //   Dibujo ‚Äì modos de brocha
  // ================================
  function drawStroke(p){
    // re-muestreo a distancia fija
    if(path.length===0){
      path.push({mode:brushMode, pts:[p]});
      return;
    }
    const seg = path[path.length-1];
    if(seg.mode !== brushMode){ // nuevo segmento si cambi√≥ modo
      path.push({mode:brushMode, pts:[p]});
      return;
    }
    const lastPt = seg.pts[seg.pts.length-1];
    const dx=p.x-lastPt.x, dy=p.y-lastPt.y, d=Math.hypot(dx,dy);
    if(d<CFG.resamplePx) return;
    const steps = Math.floor(d/CFG.resamplePx);
    for(let i=1;i<=steps;i++){
      const k=i/steps;
      const x=lastPt.x + dx*k, y=lastPt.y + dy*k;
      const np={x,y};
      seg.pts.push(np);
      drawSegmentPoint(seg, np, lastPt);
      pts.push({t:Date.now(), x, y, mar:marEma});
    }
    countEl.textContent = `pts: ${pts.length}`;
  }

  function drawSegment(seg){
    const ptsArr = seg.pts;
    for(let i=1;i<ptsArr.length;i++){
      drawSegmentPoint(seg, ptsArr[i], ptsArr[i-1]);
    }
  }

  function drawSegmentPoint(seg, p, prev){
    if(seg.mode==='line'){
      ctx.strokeStyle='rgba(0,200,255,.95)';
      ctx.lineWidth=brush; ctx.lineJoin='round'; ctx.lineCap='round';
      ctx.beginPath(); ctx.moveTo(prev.x,prev.y); ctx.lineTo(p.x,p.y); ctx.stroke();
    } else if(seg.mode==='spray'){
      const r=brush*0.9, n=6;
      for(let i=0;i<n;i++){
        const ang=Math.random()*Math.PI*2;
        const rad=Math.random()*r;
        const sx=p.x+Math.cos(ang)*rad, sy=p.y+Math.sin(ang)*rad;
        ctx.fillStyle='rgba(0,200,255,.35)';
        ctx.beginPath(); ctx.arc(sx,sy, clamp(brush*0.15,1,3), 0, Math.PI*2); ctx.fill();
      }
    } else if(seg.mode==='calli'){
      const v = Math.hypot(p.x-prev.x, p.y-prev.y);
      const w = clamp(brush*(0.8 + Math.min(1.2, v*0.06)), 2, brush*2.4);
      ctx.strokeStyle='rgba(0,200,255,.95)'; ctx.lineWidth=w; ctx.lineJoin='round'; ctx.lineCap='round';
      ctx.beginPath(); ctx.moveTo(prev.x,prev.y); ctx.lineTo(p.x,p.y); ctx.stroke();
    }
  }

  function drawGhost(){
    gctx.clearRect(0,0,ghost.width,ghost.height);
    if(ghostPts.length<2) return;
    gctx.beginPath();
    for(let i=0;i<ghostPts.length;i++){
      const gp=ghostPts[i];
      if(i===0) gctx.moveTo(gp.x,gp.y); else gctx.lineTo(gp.x,gp.y);
    }
    gctx.lineWidth=1.5; gctx.strokeStyle='rgba(0,230,118,.35)';
    gctx.stroke();
  }

  function speedAt(x,y){
    if(!last) return 0;
    return Math.hypot(x-last.x, y-last.y);
  }

  // ================================
  //   Auto-MAR (umbral de boca)
  // ================================
  async function autoMar(){
    if(!confirm('Auto-umbral: 1) Mant√©n boca CERRADA 1.2s. 2) Luego ABRE la boca 1.2s. ¬øListo?')) return;
    const closeSamp=[], openSamp=[];
    await collect(1200, closeSamp, 'CERRADA');
    await sleep(300);
    await collect(1200, openSamp, 'ABIERTA');

    const medClose = median(closeSamp), medOpen = median(openSamp);
    const thr = (medClose*2 + medOpen*1)/3; // sesgo hacia evitar falsos positivos
    const gap = Math.max(0.02, medOpen - medClose);
    const hys = clamp(gap*0.25, 0.02, 0.12);

    mouthThr = thr; CFG.mouthHys = hys;
    saveJson(MAR_KEY, {mouthThr:thr, hys});
    alert(`‚úÖ Auto-umbral listo.\nUmbral: ${thr.toFixed(3)}  Hys: ¬±${hys.toFixed(3)}`);

    function collect(ms, bucket, label){
      return new Promise(res=>{
        const t0=performance.now();
        function step(){
          const now=performance.now();
          if(marEma!=null) bucket.push(marEma);
          if(now-t0<ms){ requestAnimationFrame(step); }
          else res();
        }
        step();
      });
    }
  }

  // ================================
  //   Calibraci√≥n ROI Avanzada (igual + mejoras menores)
  // ================================
  function defineRoiWithMouse(){
    alert('Arrastra con el mouse para dibujar la zona (ROI) donde mirar√°s con los ojos.');
    const r=stageEl.getBoundingClientRect();
    let start=null, rectEl=null;

    function onDown(e){
      start={x:e.clientX - r.left, y:e.clientY - r.top};
      if(!rectEl){
        rectEl=document.createElement('div');
        rectEl.className='roi-rect';
        roiOverlay.appendChild(rectEl);
      }
      placeRect(start.x,start.y,1,1);
      window.addEventListener('mousemove',onMove);
      window.addEventListener('mouseup',onUp,{once:true});
    }
    function onMove(e){
      const x=e.clientX - r.left, y=e.clientY - r.top;
      const x0=Math.min(start.x,x), y0=Math.min(start.y,y);
      const x1=Math.max(start.x,x), y1=Math.max(start.y,y);
      placeRect(x0,y0, x1-x0, y1-y0);
    }
    function onUp(e){
      window.removeEventListener('mousemove',onMove);
      const bb=rectEl.getBoundingClientRect();
      const x0=(bb.left - r.left)/r.width, y0=(bb.top - r.top)/r.height;
      const x1=(bb.right - r.left)/r.width, y1=(bb.bottom - r.top)/r.height;
      roiNorm = {x0:clamp01(x0), y0:clamp01(y0), x1:clamp01(x1), y1:clamp01(y1)};
      saveJson(ROI_KEY, roiNorm);
      alert('ROI guardada. Ahora puedes ejecutar la Calibraci√≥n guiada.');
    }
    stageEl.addEventListener('mousedown',onDown,{once:true});

    function placeRect(x,y,w,h){
      rectEl.style.left=x+'px';
      rectEl.style.top=y+'px';
      rectEl.style.width=w+'px';
      rectEl.style.height=h+'px';
    }
  }

  function drawRoiRect(){
    roiOverlay.innerHTML='';
    const r=stageEl.getBoundingClientRect();
    const x0=roiNorm.x0*r.width, y0=roiNorm.y0*r.height;
    const w =(roiNorm.x1-roiNorm.x0)*r.width;
    const h =(roiNorm.y1-roiNorm.y0)*r.height;
    const rectEl=document.createElement('div');
    rectEl.className='roi-rect';
    rectEl.style.left=x0+'px'; rectEl.style.top=y0+'px';
    rectEl.style.width=w+'px'; rectEl.style.height=h+'px';
    roiOverlay.appendChild(rectEl);
  }

  async function guidedRoiCalibration(){
    if(CFG.controlMode!=='eyes'){
      alert('La calibraci√≥n guiada aplica al control por OJOS. Cambia ‚ÄúMover brocha con‚Äù a OJOS y vuelve a intentar.');
      return;
    }
    const r=stageEl.getBoundingClientRect();
    const rx0=roiNorm.x0*r.width, ry0=roiNorm.y0*r.height;
    const rw =(roiNorm.x1-roiNorm.x0)*r.width;
    const rh =(roiNorm.y1-roiNorm.y0)*r.height;

    const nx=[0,0.5,1], ny=[0,0.5,1];
    const targets=[];
    for(const ix of nx) for(const iy of ny){
      targets.push({ x: rx0 + ix*rw, y: ry0 + iy*rh });
    }

    roiOverlay.innerHTML='';
    drawRoiRect();
    const els=[];
    for(const t of targets){
      const el=document.createElement('div');
      el.className='calib-target wait';
      el.style.left=t.x+'px'; el.style.top=t.y+'px';
      roiOverlay.appendChild(el);
      els.push(el);
    }

    alert('Calibraci√≥n: haz clic en cada punto y MIRA ese punto ~1.2s.');

    const gazePts=[], tgtPts=[];
    for(let i=0;i<targets.length;i++){
      const el=els[i]; const t=targets[i];
      await new Promise(res=>{
        const onceClick = async ()=>{
          el.classList.remove('wait'); el.classList.add('calib-target');
          const samples=[]; const t0=performance.now();
          function step(){
            const now=performance.now();
            if(gaze.x!=null&&gaze.y!=null){
              const rb=stageEl.getBoundingClientRect();
              samples.push([gaze.x - rb.left, gaze.y - rb.top]);
            }
            if(now-t0<1200){ requestAnimationFrame(step); }
            else{
              const m=mean2(samples);
              if(!isNaN(m[0])){ gazePts.push(m); tgtPts.push([t.x, t.y]); }
              el.classList.add('done'); res();
            }
          }
          requestAnimationFrame(step);
        };
        el.addEventListener('click', onceClick, {once:true});
      });
      await sleep(150);
    }

    const sol=lsqAffine(gazePts, tgtPts);
    if(sol){ A=sol.A; b=sol.b; saveJson(LS_KEY,{A,b}); alert('‚úÖ Calibraci√≥n af√≠n completada y guardada.'); }
    else{ alert('No se pudo calibrar (muestras insuficientes o degeneradas).'); }
  }

  // -------- utils --------
  function sleep(ms){return new Promise(r=>setTimeout(r,ms));}
  function mean2(a){if(!a.length)return[NaN,NaN];const sx=a.reduce((s,v)=>s+v[0],0), sy=a.reduce((s,v)=>s+v[1],0);return[sx/a.length, sy/a.length];}
  function median(arr){ if(!arr.length) return NaN; const a=[...arr].sort((x,y)=>x-y), m=Math.floor(a.length/2); return a.length%2 ? a[m] : (a[m-1]+a[m])/2; }
  function clamp01(v){return Math.max(0,Math.min(1,v));}
  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
  function clampStep(sx,sy,nx,ny,maxStep){
    const dx=nx-sx, dy=ny-sy, d=Math.hypot(dx,dy);
    if(!isFinite(d) || d===0) return [sx,sy];
    if(d<=maxStep) return [nx,ny];
    const k=maxStep/d; return [sx+dx*k, sy+dy*k];
  }
  function transpose(A){const m=A.length,n=A[0].length,AT=Array.from({length:n},()=>Array(m).fill(0));for(let i=0;i<m;i++)for(let j=0;j<n;j++)AT[j][i]=A[i][j];return AT;}
  function mul(A,B){const m=A.length,n=A[0].length,p=B[0].length,C=Array.from({length:m},()=>Array(p).fill(0));for(let i=0;i<m;i++)for(let k=0;k<n;k++)for(let j=0;j<p;j++)C[i][j]+=A[i][k]*B[k][j];return C;}
  function mulVec(A,v){const m=A.length,n=A[0].length,r=Array(m).fill(0);for(let i=0;i<m;i++)for(let j=0;j<n;j++)r[i]+=A[i][j]*v[j];return r;}
  function solveGaussian(A,b){const n=A.length,M=A.map((row,i)=>row.concat([b[i]]));for(let i=0;i<n;i++){let max=i;for(let r=i+1;r<n;r++)if(Math.abs(M[r][i])>Math.abs(M[max][i]))max=r;if(Math.abs(M[max][i])<1e-9)return null;[M[i],M[max]]=[M[max],M[i]];const piv=M[i][i];for(let k=i;k<=n;k++)M[i][k]/=piv;for(let r=0;r<n;r++)if(r!==i){const f=M[r][i];for(let k=i;k<=n;k++)M[r][k]-=f*M[i][k];}}return M.map(row=>row[n]);}
  function lsqAffine(gPts,tPts){
    if(!gPts.length || gPts.length<3) return null;
    const M=[],Z=[];
    for(let i=0;i<gPts.length;i++){
      const[gx,gy]=gPts[i]; const[tx,ty]=tPts[i];
      M.push([gx,gy,0,0,1,0]); Z.push(tx);
      M.push([0,0,gx,gy,0,1]); Z.push(ty);
    }
    const Mt=transpose(M),MtM=mul(Mt,M),MtZ=mulVec(Mt,Z),p=solveGaussian(MtM,MtZ);
    return p?{A:[p[0],p[1],p[2],p[3]],b:[p[4],p[5]]}:null;
  }
  function saveJson(k,v){ try{ localStorage.setItem(k, JSON.stringify(v)); }catch(e){} }
  function loadJson(k){ try{ const s=localStorage.getItem(k); return s?JSON.parse(s):null; }catch(e){ return null; } }

})();
</script>
</body>
</html>
