<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Brocha Ocular</title>

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh"></script>

<style>
  html, body { margin:0; padding:0; height:100%; overflow:hidden; background:#0f1115; color:#fff; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif }
  #wrap { position:relative; width:100%; height:100vh }
  #topbar { position:absolute; top:10px; left:10px; right:10px; display:flex; gap:8px; flex-wrap:wrap; background:rgba(0,0,0,.45); padding:8px 10px; border-radius:10px; align-items:center; z-index:10000; box-shadow: 0 4px 6px rgba(0,0,0,.15) }
  .btn { appearance:none; border:0; padding:8px 14px; border-radius:10px; cursor:pointer; background:#2b2f3a; color:#fff; font-weight:600; transition: background .2s, transform .1s; }
  .btn:hover { background: #3b424f; }
  .btn:active { transform: scale(0.98); }
  .btn.primary { background:#00e676; color:#111; }
  .btn.primary:hover { background: #00c853; }
  .btn.warn { background:#ff5252; }
  .btn.warn:hover { background: #e04545; }
  .sp { margin-left:auto; font:12px/1.2 monospace; opacity:.9 }
  #stage { position:absolute; inset:62px 10px 10px 10px; border-radius:10px; background:#10131a; overflow:hidden; box-shadow: 0 4px 6px rgba(0,0,0,.15); }
  #canvas { position:absolute; inset:0; width:100%; height:100% }
  #cursor { position:absolute; width:20px; height:20px; border:3px solid rgba(255,255,255,.95); border-radius:50%; pointer-events:none; transform:translate(-50%,-50%); display:none; transition: all .05s ease-out; }
  #status { position:absolute; bottom:10px; left:10px; right:10px; display:flex; gap:10px; align-items:center; background:rgba(255,255,255,.06); padding:8px 10px; border-radius:10px; z-index:9999; box-shadow: 0 -2px 4px rgba(0,0,0,.1) }
  #modeTag { font-weight:700; background:#1f2937; padding:4px 8px; border-radius:8px }
  #marPanel { display:flex; align-items:center; gap:8px; flex:1 }
  #marBar { position:relative; height:12px; flex:1; background:#2b2f3a; border-radius:6px; overflow:hidden }
  #marFill { position:absolute; top:0; left:0; height:100%; width:0%; background:#00e676; transition: width .1s ease-out; }
  #marThr { position:absolute; top:-3px; width:2px; height:18px; background:#ff5252; left:50% }
  #marVal { min-width:140px; text-align:right; font:12px/1 monospace; opacity:.9 }
  #dbg { position:absolute; right:10px; bottom:10px; background:rgba(0,0,0,.55); padding:6px 8px; border-radius:8px; font:12px/1.2 monospace; opacity: .8 }
  video#rawVideo { display:none }
  #errbar { position:absolute; top:0; left:0; right:0; background:#ff3344; color:#100; padding:6px 10px; font:12px/1.3 monospace; display:none; z-index:10001; text-align: center; }
  .calib-step-ui { position:absolute; inset:0; display:flex; flex-direction:column; justify-content:center; align-items:center; background:rgba(0,0,0,0.7); z-index:100; }
  .calib-step-ui h2 { margin:0; padding:10px; font-size: 2em; }
  .calib-step-ui p { margin:5px 0 20px; font-size: 1.2em; max-width: 600px; text-align: center; }
  .calib-target { position:absolute; width:18px; height:18px; border-radius:50%; background:#fbbf24; box-shadow:0 0 0 6px rgba(251,191,36,.25); transform:translate(-50%,-50%); pointer-events:auto; cursor:crosshair; transition: all .3s }
</style>
</head>
<body>
<div id="wrap">
  <div id="topbar">
    <button id="testCam" class="btn primary">Iniciar Cámara</button>
    <button id="btnCalibrate" class="btn">Calibrar Límites</button>
    <button id="btnStart" class="btn">Iniciar Brocha</button>
    <button id="btnClear" class="btn warn">🧹 Limpiar</button>
    <span class="sp" id="count">pts: 0</span>
  </div>

  <div id="stage">
    <canvas id="canvas"></canvas>
    <div id="cursor"></div>
    <div id="calibUI" class="calib-step-ui" style="display: none;">
      <h2 id="calibTitle"></h2>
      <p id="calibDescription"></p>
    </div>
    <div id="dbg" style="display:none"></div>
    <video id="rawVideo" playsinline autoplay muted></video>
  </div>

  <div id="status">
    <span id="modeTag">Modo: Esperando</span>
    <div id="marPanel">
      <span>MAR:</span>
      <div id="marBar"><div id="marFill"></div><div id="marThr"></div></div>
      <span id="marVal">—</span>
    </div>
  </div>

  <div id="errbar"></div>
</div>

<script>
(function(){
  // --- Estado de la aplicación ---
  let mode = 'idle'; // 'idle', 'calibrating_limits', 'brush'
  let isPainting = false;
  let isFaceDetected = false;
  
  // --- Configuración (ajustable) ---
  const CFG = {
    brush: 12,
    mouthThr: 0.28,
    mouthHys: 0.05,
    marMedianN: 5,
    marEmaAlpha: 0.30,
    // --- CAMBIO: Usaremos una matriz de transformación afín en lugar de offset/scale
    transform: [1, 0, 0, 0, 1, 0], // Matriz identidad [a, b, c, d, e, f]
    // Margen de calibración en % del viewport
    calib_margin_x: 0.1,
    calib_margin_y: 0.1,
  };

  // --- Elementos del DOM ---
  const errbar = document.getElementById('errbar');
  const stageEl = document.getElementById('stage');
  const canvas = document.getElementById('canvas'); const ctx = canvas.getContext('2d');
  const cursor = document.getElementById('cursor');
  const rawVideo = document.getElementById('rawVideo');
  const countEl = document.getElementById('count');
  const modeTag = document.getElementById('modeTag');
  const marVal = document.getElementById('marVal');
  const marFill = document.getElementById('marFill');
  const marThr = document.getElementById('marThr');
  const calibUI = document.getElementById('calibUI');
  const calibTitle = document.getElementById('calibTitle');
  const calibDescription = document.getElementById('calibDescription');
  const btnCalibrate = document.getElementById('btnCalibrate');
  const btnStart = document.getElementById('btnStart');

  // --- Señales y datos ---
  let W, H;
  let irisN = {x: null, y: null};
  let marEma = null;
  let lastPoint = null;
  let drawingPoints = [];
  let calibrationPoints = [];

  // --- Funciones de Utilidad ---
  function showErr(msg) { errbar.textContent = `⚠️ ${msg}`; errbar.style.display = 'block'; }
  function showInfo(msg) { errbar.textContent = `ℹ️ ${msg}`; errbar.style.display = 'block'; }
  function hideErr() { errbar.style.display = 'none'; }
  function median(arr) { if(!arr.length) return NaN; const a=[...arr].sort((x,y)=>x-y), m=Math.floor(a.length/2); return a.length%2 ? a[m] : (a[m-1]+a[m])/2; }
  function dist2(a, b) { return Math.hypot(a.x - b.x, a.y - b.y); }
  function sleep(ms) { return new Promise(res => setTimeout(res, ms)); }
  function saveCalib() {
      const data = { transform: CFG.transform };
      localStorage.setItem('calibData', JSON.stringify(data));
  }
  function loadCalib() {
      try {
          const data = JSON.parse(localStorage.getItem('calibData'));
          if (data && data.transform) {
              CFG.transform = data.transform;
              showInfo("✅ Calibración guardada cargada.");
              return true;
          }
      } catch (e) {
          console.error("Error loading calibration:", e);
      }
      return false;
  }

  // --- Inicialización y Redimensionamiento ---
  function resize() {
    const dpr = window.devicePixelRatio || 1;
    const r = stageEl.getBoundingClientRect();
    W = r.width; H = r.height;
    canvas.width = Math.floor(W * dpr); canvas.height = Math.floor(H * dpr);
    canvas.style.width = W + 'px'; canvas.style.height = H + 'px';
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  window.addEventListener('resize', resize); resize();

  // --- Lógica del Gesto de la Boca (MAR) ---
  const marHist = [];
  function processMouth(landmarks) {
    const mouthH = dist2(landmarks[13], landmarks[14]);
    const mouthW = dist2(landmarks[61], landmarks[291]);
    const marRaw = mouthH / Math.max(1e-6, mouthW);
    marHist.push(marRaw);
    if (marHist.length > CFG.marMedianN) marHist.shift();
    const med = median(marHist);
    marEma = marEma == null ? med : CFG.marEmaAlpha * med + (1 - CFG.marEmaAlpha) * marEma;
    const marUi = Math.max(0, Math.min(0.8, marEma));
    marVal.textContent = `raw: ${marRaw.toFixed(3)} | filt: ${marEma.toFixed(3)}`;
    marFill.style.width = (marUi / 0.8 * 100).toFixed(0) + '%';
    marThr.style.left = (Math.max(0, Math.min(1, CFG.mouthThr / 0.8)) * 100).toFixed(0) + '%';
    
    const openThr = CFG.mouthThr + CFG.mouthHys;
    const closeThr = CFG.mouthThr - CFG.mouthHys;
    isPainting = isPainting ? (marEma > closeThr) : (marEma > openThr);
  }

  // --- Lógica de la Mirada (Iris) ---
  function processGaze(landmarks) {
    const avg = (idxs) => idxs.reduce((s, i) => ({ x: s.x + landmarks[i].x, y: s.y + landmarks[i].y }), { x: 0, y: 0 });
    const rC = avg([468, 469, 470, 471]); rC.x /= 4; rC.y /= 4;
    const lC = avg([473, 474, 475, 476]); lC.x /= 4; lC.y /= 4;

    const R_L = landmarks[133], R_R = landmarks[33];
    const L_L = landmarks[362], L_R = landmarks[263];

    const rW = Math.abs(R_R.x - R_L.x), lW = Math.abs(L_R.x - L_L.x);
    
    let irisX_norm;
    let irisY_norm;

    if (rW > 0 && lW > 0) {
        let rx_norm = (rC.x - R_L.x) / rW;
        let lx_norm = (lC.x - L_L.x) / lW;
        irisX_norm = (rx_norm + lx_norm) / 2;
    } else {
        irisX_norm = 0.5;
    }

    const R_T = landmarks[159], R_B = landmarks[145];
    const L_T = landmarks[386], L_B = landmarks[374];
    const rH = Math.abs(R_B.y - R_T.y), lH = Math.abs(L_B.y - L_T.y);

    if (rH > 0 && lH > 0) {
        let ry_norm = (rC.y - R_T.y) / rH;
        let ly_norm = (lC.y - L_T.y) / lH;
        irisY_norm = (ry_norm + ly_norm) / 2;
    } else {
        irisY_norm = 0.5;
    }
    
    irisN.x = irisX_norm;
    irisN.y = irisY_norm;
  }

  // --- Detección de Rostros y Bucle Principal ---
  const faceMesh = new FaceMesh({ locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${f}` });
  faceMesh.setOptions({ maxNumFaces: 1, refineLandmarks: true, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
  faceMesh.onResults(results => {
    if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
      if (!isFaceDetected) {
          isFaceDetected = true;
          showInfo("✅ Rostro detectado. ¡Ya puedes calibrar!");
          btnCalibrate.disabled = false;
          btnStart.disabled = false;
      }
      const lm = results.multiFaceLandmarks[0];
      processMouth(lm);
      processGaze(lm);

      // --- CAMBIO: Aplicar la transformación afín a las coordenadas del iris ---
      const [a, b, c, d, e, f] = CFG.transform;
      const px_mapped = a * irisN.x + b * irisN.y + c;
      const py_mapped = d * irisN.x + e * irisN.y + f;
      // Ya no se necesita invertY, la transformación lo maneja.

      let px = px_mapped * W;
      let py = py_mapped * H;

      const x = Math.max(0, Math.min(W, px));
      const y = Math.max(0, Math.min(H, py));

      if (mode !== 'idle') {
        cursor.style.display = 'block';
        cursor.style.left = x + 'px';
        cursor.style.top = y + 'px';
      }

      if (mode === 'brush' && isPainting) {
        if (lastPoint) {
          ctx.strokeStyle = 'rgba(0,200,255,.95)'; ctx.lineWidth = CFG.brush; ctx.lineJoin = 'round'; ctx.lineCap = 'round';
          ctx.beginPath();
          ctx.moveTo(lastPoint.x, lastPoint.y);
          ctx.lineTo(x, y);
          ctx.stroke();
          drawingPoints.push({ x: x, y: y, mar: marEma, t: Date.now() });
          countEl.textContent = `pts: ${drawingPoints.length}`;
        }
        lastPoint = { x, y };
      } else {
        lastPoint = null;
      }
      
    } else {
      isFaceDetected = false;
      cursor.style.display = 'none';
      btnCalibrate.disabled = true;
      btnStart.disabled = true;
      showErr("❌ No se detecta tu rostro. Acércate a la cámara.");
    }
  });

  async function startCamera() {
    if (rawVideo.srcObject) return;
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ video: { width: { ideal:1280 }, height: { ideal:720 }, facingMode:"user" } });
      rawVideo.srcObject = stream;
      await rawVideo.play();
      hideErr();
      requestAnimationFrame(faceLoop);
      if (!loadCalib()) {
        showInfo('Cámara lista. Por favor, calibra tu mirada.');
      }
    } catch (e) {
      showErr(`No se pudo acceder a la cámara. ${e.name}: ${e.message}`);
    }
  }

  async function faceLoop() {
    if (rawVideo.readyState >= 2 && !rawVideo.paused && !rawVideo.ended) {
      await faceMesh.send({ image: rawVideo });
    }
    requestAnimationFrame(faceLoop);
  }

  // --- Funciones de Calibración ---
  function showCalibUI(title, description) {
    calibUI.style.display = 'flex';
    calibTitle.textContent = title;
    calibDescription.textContent = description;
  }

  function hideCalibUI() {
    calibUI.style.display = 'none';
    const targets = document.querySelectorAll('.calib-target');
    targets.forEach(t => t.remove());
  }
  
  async function startCalibLimits() {
    if (!isFaceDetected) {
      showErr('No se detecta tu rostro. Por favor, asegúrate de que la cámara esté activa.');
      return;
    }
    
    // Generar 9 puntos de calibración responsivos (esto ya estaba bien)
    calibrationPoints = [];
    const marginX = W * CFG.calib_margin_x;
    const marginY = H * CFG.calib_margin_y;
    const stepX = (W - 2 * marginX) / 2;
    const stepY = (H - 2 * marginY) / 2;

    for (let i = 0; i < 3; i++) {
        for (let j = 0; j < 3; j++) {
            const px = marginX + j * stepX;
            const py = marginY + i * stepY;
            calibrationPoints.push({ x: px, y: py, sample: null, el: null });
        }
    }

    mode = 'calibrating_limits';
    modeTag.textContent = 'Modo: Calibrando';
    
    showInfo("Iniciando calibración de límites...");
    
    showCalibUI("Calibración en Progreso", "Mira cada punto amarillo que aparezca y haz clic en él para capturar la posición de tu mirada.");
    await sleep(2000);

    for (const point of calibrationPoints) {
        const el = document.createElement('div');
        el.className = 'calib-target';
        el.style.left = point.x + 'px';
        el.style.top = point.y + 'px';
        stageEl.appendChild(el); // Añadir al stage para que esté debajo de calibUI
        point.el = el;

        await new Promise(res => {
            el.onclick = () => {
                point.sample = {x: irisN.x, y: irisN.y};
                el.style.background = '#00e676';
                res();
            };
        });
    }
    
    await sleep(500);
    hideCalibUI();
    calculateAffineMapping();
    saveCalib();
    showInfo("✅ Calibración completa. Puedes iniciar la brocha.");
    btnStart.disabled = false;
    mode = 'idle';
    modeTag.textContent = 'Modo: Esperando';
  }
  
  // --- CAMBIO TOTAL: Función reescrita para calcular una transformación afín ---
  function calculateAffineMapping() {
    if (!isFaceDetected || calibrationPoints.some(p => p.sample === null)) {
      showErr('Faltan puntos de calibración. Por favor, recalibra.');
      return;
    }

    // Usaremos 3 puntos para resolver el sistema de ecuaciones:
    // P0: Top-Left, P2: Top-Right, P6: Bottom-Left
    const P0 = calibrationPoints[0];
    const P2 = calibrationPoints[2];
    const P6 = calibrationPoints[6];

    // Puntos de origen (datos del iris)
    const s0 = P0.sample;
    const s2 = P2.sample;
    const s6 = P6.sample;

    // Puntos de destino (coordenadas de la pantalla, normalizadas a 0-1)
    const d0 = { x: P0.x / W, y: P0.y / H };
    const d2 = { x: P2.x / W, y: P2.y / H };
    const d6 = { x: P6.x / W, y: P6.y / H };

    // Creamos una matriz para resolver el sistema de ecuaciones:
    // [s0.x, s0.y, 1] [a, d] = [d0.x, d0.y]
    // [s2.x, s2.y, 1] [b, e] = [d2.x, d2.y]
    // [s6.x, s6.y, 1] [c, f] = [d6.x, d6.y]
    
    // Resolvemos para (a, b, c) -> que mapean a X'
    let A = [
        [s0.x, s0.y, 1],
        [s2.x, s2.y, 1],
        [s6.x, s6.y, 1]
    ];
    let Bx = [d0.x, d2.x, d6.x];
    
    // Resolvemos para (d, e, f) -> que mapean a Y'
    let By = [d0.y, d2.y, d6.y];

    // Función para resolver el sistema 3x3 (usando la regla de Cramer)
    function solve(matrix, vector) {
        const det = (m) => m[0][0]*(m[1][1]*m[2][2]-m[2][1]*m[1][2]) - m[0][1]*(m[1][0]*m[2][2]-m[1][2]*m[2][0]) + m[0][2]*(m[1][0]*m[2][1]-m[1][1]*m[2][0]);
        const mainDet = det(matrix);
        if (Math.abs(mainDet) < 1e-9) return null; // Matriz singular, no se puede resolver

        const res = [];
        for (let i = 0; i < 3; i++) {
            let tempMatrix = matrix.map(row => [...row]);
            for (let j = 0; j < 3; j++) {
                tempMatrix[j][i] = vector[j];
            }
            res.push(det(tempMatrix) / mainDet);
        }
        return res;
    }

    const X = solve(A, Bx); // Solución para [a, b, c]
    const Y = solve(A, By); // Solución para [d, e, f]

    if (X && Y) {
        CFG.transform = [X[0], X[1], X[2], Y[0], Y[1], Y[2]];
        console.log("Nueva matriz de transformación:", CFG.transform);
    } else {
        showErr("No se pudo calcular la calibración. Puntos colineales o duplicados.");
    }
  }

  // --- Eventos de Botones ---
  document.getElementById('testCam').onclick = startCamera;
  document.getElementById('btnCalibrate').onclick = startCalibLimits;
  document.getElementById('btnStart').onclick = () => {
    if (!calibrationPoints.some(p => p.sample !== null)) {
        showErr("Debes calibrar primero antes de iniciar la brocha.");
        return;
    }
    mode = 'brush';
    modeTag.textContent = 'Modo: Brocha';
    showInfo('¡Mueve tus ojos para dibujar! Abre la boca para activar la brocha.');
  };
  document.getElementById('btnClear').onclick = () => {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawingPoints = [];
    countEl.textContent = 'pts: 0';
  };

})();
</script>
</body>
</html>
