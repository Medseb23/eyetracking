<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Brocha: Ojos/Iris o Nariz + Boca (Calibraci√≥n por iris normalizado)</title>

<!-- (Opcional) WebGazer fallback -->
<script src="https://webgazer.cs.brown.edu/webgazer.js"></script>
<!-- MediaPipe FaceMesh (con Iris) -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh"></script>

<style>
  html,body{margin:0;padding:0;height:100%;overflow:hidden;background:#0f1115;color:#fff}
  #wrap{position:relative;width:100%;height:100vh}
  #topbar{position:absolute;top:10px;left:10px;right:10px;display:flex;gap:8px;flex-wrap:wrap;background:rgba(0,0,0,.45);padding:8px 10px;border-radius:10px;align-items:center;z-index:10000}
  .btn{appearance:none;border:0;padding:6px 10px;border-radius:10px;cursor:pointer;background:#22272e;color:#fff;font-weight:600}
  .btn.primary{background:#00e676;color:#111}
  .btn.warn{background:#ff5252}
  .sp{margin-left:auto;font:12px/1.2 monospace;opacity:.9}
  #stage{position:absolute;inset:62px 10px 10px 10px;border-radius:10px;background:#10131a;overflow:hidden}
  #canvas{position:absolute;inset:0;width:100%;height:100%}
  #cursor{position:absolute;width:20px;height:20px;border:2px solid rgba(255,255,255,.95);border-radius:50%;pointer-events:none;transform:translate(-50%,-50%);display:none}
  #status{position:absolute;bottom:10px;left:10px;right:10px;display:flex;gap:10px;align-items:center;background:rgba(255,255,255,.06);padding:8px 10px;border-radius:10px;z-index:9999}
  #modeTag{font-weight:700;background:#1f2937;padding:4px 8px;border-radius:8px}
  #marPanel{display:flex;align-items:center;gap:8px;flex:1}
  #marBar{position:relative;height:10px;flex:1;background:#2b2f3a;border-radius:6px;overflow:hidden}
  #marFill{position:absolute;top:0;left:0;height:100%;width:0%;background:#00e676}
  #marThr{position:absolute;top:-3px;width:2px;height:16px;background:#ff5252;left:50%}
  #marVal{min-width:140px;text-align:right;font:12px/1 monospace;opacity:.9}
  #preview{position:absolute;top:10px;right:10px;width:300px;height:225px;background:#000a;border-radius:8px;display:none;z-index:5000}
  video#rawVideo{display:none}
  #errbar{position:absolute;bottom:0;left:0;right:0;background:#ff3344;color:#100;padding:6px 10px;font:12px/1.3 monospace;display:none;z-index:10001}
  .roi-overlay{position:absolute;inset:0;pointer-events:none}
  .roi-rect{position:absolute;border:2px dashed rgba(0,230,118,.9);border-radius:8px;box-shadow:0 0 0 200vmax rgba(0,0,0,.45) inset}
  .calib-target{position:absolute;width:18px;height:18px;border-radius:50%;background:#00e676;box-shadow:0 0 0 6px rgba(0,230,118,.2);transform:translate(-50%,-50%);pointer-events:auto;cursor:crosshair}
  .calib-target.wait{background:#fbbf24; box-shadow:0 0 0 6px rgba(251,191,36,.25)}
  .calib-target.done{background:#22d3ee; box-shadow:0 0 0 6px rgba(34,211,238,.25)}
  .badge{padding:2px 6px;border-radius:6px;background:#1f2937;margin-left:6px;font:12px/1 monospace}
</style>
</head>
<body>
<div id="wrap">
  <div id="topbar">
    <button id="testCam" class="btn">üé• Probar c√°mara</button>
    <button id="modeFace" class="btn">1) Test de Boca</button>
    <button id="modeGaze" class="btn">2) Test de Movimiento</button>
    <button id="modeBrush" class="btn primary">3) Iniciar Brocha</button>

    <button id="btnRoi" class="btn">üñ±Ô∏è ROI</button>
    <button id="btnCalRoi" class="btn">üéØ Calibraci√≥n OJOS (ROI)</button>
    <button id="btnResetCal" class="btn warn">‚ôªÔ∏è Reset Calibraci√≥n</button>

    <button id="btnAnchors" class="btn">üîß Anclas anti-drift</button>
    <button id="togglePreview" class="btn">üëÅÔ∏è Preview</button>
    <button id="clear" class="btn warn">üßπ Limpiar</button>
    <button id="savePng" class="btn">üñºÔ∏è PNG</button>
    <button id="saveCsv" class="btn">üìÑ CSV</button>
    <span class="sp" id="count">pts: 0</span>
  </div>

  <div id="stage">
    <canvas id="canvas"></canvas>
    <div id="cursor"></div>
    <canvas id="preview"></canvas>
    <video id="rawVideo" playsinline autoplay muted></video>
    <div class="roi-overlay" id="roiOverlay"></div>
  </div>

  <div id="status">
    <span id="modeTag">Modo: Test de Boca</span>
    <div id="marPanel">
      <span>MAR:</span>
      <div id="marBar"><div id="marFill"></div><div id="marThr"></div></div>
      <span id="marVal">‚Äî</span>
      <span class="badge" id="ctlBadge">Control: OJOS (Iris)</span>
      <span class="badge" id="ancBadge">Anclas: OFF</span>
    </div>
  </div>

  <div id="errbar"></div>
</div>

<script>
(function(){
  // ---------- errores visibles ----------
  const errbar=document.getElementById('errbar');
  function showErr(msg){ errbar.textContent='‚ö†Ô∏è '+msg; errbar.style.display='block'; }
  window.onerror=(m,src,l,c)=>showErr((m||'Error')+(l?` @${l}:${c||0}`:''));
  window.onunhandledrejection=(ev)=>showErr('Promise rejection: '+(ev.reason?.message||ev.reason||''));

  // ---------- config ----------
  const CFG = Object.assign({
    brush:8, alpha:.20, mouthThr:.28, debug:true, controlMode:'eyes',
    useIris:true,
    invertX:false,  // ‚Üê prueba con true para corregir "espejo" horizontal
    invertY:false,
    gainX:1.15, gainY:1.15,           // ganancia previa a calibraci√≥n
    deadzonePx:6, maxStepPx:22, medianN:5, mouthHys:.05,
    marMedianN:5, marEmaAlpha:.30,
    marUseEyeScale:true, marEyeFactor:0.35,
    detConf:.5, trackConf:.5,
    snap:{enabled:true,size:64,radius:22,blend:0.7},
    anchors:{enabled:true, dwellMs:300, radiusPx:28, adjust:0.12}
  }, window.DIAG_CFG||{});

  // ---------- DOM ----------
  const stageEl=document.getElementById('stage');
  const canvas=document.getElementById('canvas'); const ctx=canvas.getContext('2d');
  const cursor=document.getElementById('cursor');
  const preview=document.getElementById('preview'); const pctx=preview.getContext('2d');
  const rawVideo=document.getElementById('rawVideo');
  const countEl=document.getElementById('count'); const modeTag=document.getElementById('modeTag');
  const marVal=document.getElementById('marVal'); const marFill=document.getElementById('marFill'); const marThr=document.getElementById('marThr');
  const roiOverlay=document.getElementById('roiOverlay');
  const ctlBadge=document.getElementById('ctlBadge'); const ancBadge=document.getElementById('ancBadge');

  // ---------- estado ----------
  let mode='face';
  let brush=CFG.brush, alpha=CFG.alpha, mouthThr=CFG.mouthThr;
  let dpr=1, W=0, H=0, pts=[], last=null;

  // se√±ales
  let irisN={x:null,y:null};     // ‚Üê mirada NORMALIZADA (0..1) para calibraci√≥n/uso
  let nose={x:null,y:null,z:null};
  let faceBox=null;

  // af√≠n (mapa irisN‚Üíp√≠xeles), ROI, anclas
  // pixel = A¬∑irisN + b
  let A=[W||1,0,0,H||1]; // se sobreescribe tras calibrar
  let b=[0,0];
  const LS_KEY='diag_calib_affine_irisN_v1';
  const ROI_KEY='diag_roi_norm_v3';
  const ANC_KEY='diag_anchors_on_v1';
  let roiNorm = loadJson(ROI_KEY) || {x0:0.08,y0:0.08,x1:0.92,y1:0.92};
  let anchorsOn = loadJson(ANC_KEY) ?? !!CFG.anchors.enabled;
  let dwellStart=null, currentAnchor=null;

  // MAR (boca)
  let marHist=[], marEma=null, isPainting=false;

  // worker Kalman
  const kalmanWorker = makeKalmanWorker();
  let kalmanReady=false;
  kalmanWorker.onmessage = (e)=>{
    if(e.data?.ready){ kalmanReady=true; return; }
    if(e.data?.out){ drawFiltered(e.data.out.x, e.data.out.y); }
  };
  kalmanWorker.postMessage({cfg:{procNoise:1e-2, measNoise:2.0, maxStep:CFG.maxStepPx, deadzone:CFG.deadzonePx}});

  // ---------- tama√±o ----------
  function resize(){
    dpr=Math.min(window.devicePixelRatio||1,2);
    const r=stageEl.getBoundingClientRect();
    canvas.width=Math.floor(r.width*dpr); canvas.height=Math.floor(r.height*dpr);
    canvas.style.width=r.width+'px'; canvas.style.height=r.height+'px'; ctx.setTransform(dpr,0,0,dpr,0,0);
    preview.width=Math.floor(300*dpr); preview.height=Math.floor(225*dpr);
    preview.style.width='300px'; preview.style.height='225px'; pctx.setTransform(dpr,0,0,dpr,0,0);
    W=r.width; H=r.height;
    drawRoiRect();
  }
  window.addEventListener('resize', resize); resize();

  // ---------- UI ----------
  document.getElementById('modeFace').onclick=()=>setMode('face');
  document.getElementById('modeGaze').onclick=()=>setMode('gmove');
  document.getElementById('modeBrush').onclick=()=>setMode('brush');
  document.getElementById('togglePreview').onclick=()=>{preview.style.display=(preview.style.display==='none'||preview.style.display==='')?'block':'none';};
  document.getElementById('clear').onclick=()=>{ctx.clearRect(0,0,canvas.width,canvas.height); pts=[]; countEl.textContent='pts: 0'; last=null;};
  document.getElementById('savePng').onclick=()=>{const a=document.createElement('a'); a.download=`brocha_${Date.now()}.png`; a.href=canvas.toDataURL('image/png'); a.click();};
  document.getElementById('saveCsv').onclick=()=>{
    const header='t_ms,x,y,mar,mode\n';
    const body=pts.map(p=>`${p.t},${Math.round(p.x)},${Math.round(p.y)},${(p.mar??0).toFixed(4)},${CFG.controlMode}`).join('\n');
    const blob=new Blob([header+body],{type:'text/csv'}); const url=URL.createObjectURL(blob);
    const a=document.createElement('a'); a.href=url; a.download=`brocha_${CFG.controlMode}_${Date.now()}.csv`; a.click(); URL.revokeObjectURL(url);
  };
  document.getElementById('btnRoi').onclick = defineRoiWithMouse;
  document.getElementById('btnCalRoi').onclick = guidedRoiCalibration;
  document.getElementById('btnResetCal').onclick = ()=>{ A=[1,0,0,1]; b=[0,0]; saveJson(LS_KEY,{A,b}); alert('Calibraci√≥n reiniciada.'); };
  document.getElementById('btnAnchors').onclick = ()=>{
    anchorsOn=!anchorsOn; saveJson(ANC_KEY, anchorsOn);
    ancBadge.textContent = 'Anclas: ' + (anchorsOn?'ON':'OFF');
  };
  ancBadge.textContent = 'Anclas: ' + (anchorsOn?'ON':'OFF');
  ctlBadge.textContent = 'Control: ' + (CFG.controlMode==='nose'?'NARIZ':'OJOS (Iris)');

  function setMode(m){
    mode=m;
    modeTag.textContent='Modo: '+(m==='face'?'Test de Boca': m==='gmove'?'Test de Movimiento':'Brocha');
    if(m==='face') cursor.style.display='none';
  }

  // ---------- c√°mara ----------
  let gStream=null;
  async function startCameraFlow(auto=false){
    try{
      gStream=await navigator.mediaDevices.getUserMedia({
        video:{width:{ideal:1280},height:{ideal:720},frameRate:{ideal:60,max:60},facingMode:"user"},
        audio:false
      });
      rawVideo.srcObject=gStream; await rawVideo.play(); errbar.style.display='none';
      if(!auto) alert('‚úÖ C√°mara iniciada.');
    }catch(e){
      const hintIframe = (window.self !== window.top) ? "\nüëâ Si est√°s en Streamlit, embebe el iframe con allow=\"camera; microphone\"." : "";
      showErr('No se pudo acceder a la c√°mara: '+(e.name||'')+' ‚Äî '+(e.message||e)+hintIframe+"\nPulsa ¬´Probar c√°mara¬ª para reintentar.");
    }
  }
  document.getElementById('testCam').onclick=()=>startCameraFlow(false);
  window.addEventListener('load', ()=>startCameraFlow(true));

  // ---------- FaceMesh (Iris, boca, nariz) ----------
  const faceMesh=new FaceMesh({ locateFile:(f)=>`https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${f}` });
  faceMesh.setOptions({ maxNumFaces:3, refineLandmarks:true, minDetectionConfidence: CFG.detConf, minTrackingConfidence: CFG.trackConf });

  function bboxOf(lm){let minx=1,miny=1,maxx=0,maxy=0; for(const p of lm){minx=Math.min(minx,p.x); miny=Math.min(miny,p.y); maxx=Math.max(maxx,p.x); maxy=Math.max(maxy,p.y);} return {minx,miny,maxx,maxy,cx:(minx+maxx)/2,cy:(miny+maxy)/2,area:(maxx-minx)*(maxy-miny)};}
  function pickMainFace(arr){ if(!arr||!arr.length) return null; let k=0,b=Infinity; for(let i=0;i<arr.length;i++){ const bb=bboxOf(arr[i]); const dc=(bb.cx-0.5)**2+(bb.cy-0.5)**2; const s=dc/(bb.area+1e-6); if(s<b){b=s;k=i;} } return arr[k]; }
  function dist2(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }

  async function faceLoop(){ try{ if(rawVideo.readyState>=2 && !rawVideo.paused && !rawVideo.ended){ await faceMesh.send({image:rawVideo}); } }catch(e){ showErr('faceLoop: '+e.message); } requestAnimationFrame(faceLoop); }

  faceMesh.onResults(res=>{
    if(!res.multiFaceLandmarks || !res.multiFaceLandmarks.length) return;
    const lm = pickMainFace(res.multiFaceLandmarks); if(!lm) return;

    faceBox = bboxOf(lm);
    if (faceBox.area < 0.02) return;

    // --- Boca (MAR) ---
    const mouthH = dist2(lm[13], lm[14]);
    const mouthW = dist2(lm[61], lm[291]);
    const eyeDst  = dist2(lm[33], lm[263]);
    const denom = (CFG.marUseEyeScale) ? Math.max(mouthW, CFG.marEyeFactor*eyeDst) : mouthW;
    const marRaw = mouthH / Math.max(1e-6, denom);
    marHist.push(marRaw); if(marHist.length>CFG.marMedianN) marHist.shift();
    const med = median(marHist); marEma = (marEma==null)? med : CFG.marEmaAlpha*med + (1-CFG.marEmaAlpha)*marEma;
    const marUi = Math.max(0, Math.min(0.8, marEma));
    marVal.textContent = `raw:${marRaw.toFixed(3)}  filt:${marEma.toFixed(3)}`;
    marFill.style.width = (marUi/0.8*100).toFixed(0)+'%';
    marThr.style.left = (Math.max(0, Math.min(1, mouthThr/0.8))*100).toFixed(0)+'%';

    // --- Nariz ---
    const NOSE_IDX=[1,4];
    let nz=lm[NOSE_IDX[0]]; for(const idx of NOSE_IDX){ if(lm[idx] && lm[idx].z < nz.z) nz = lm[idx]; }
    nose = {x:nz.x, y:nz.y, z:nz.z};

    // --- Ojos con Iris ‚Üí irisN (normalizado 0..1) ---
    // centros del iris
    const avg = (idxs)=> idxs.reduce((s,i)=>({x:s.x+lm[i].x, y:s.y+lm[i].y}), {x:0,y:0});
    const rC=avg([468,469,470,471]); rC.x/=4; rC.y/=4;
    const lC=avg([473,474,475,476]); lC.x/=4; lC.y/=4;

    // extremos horizontales (ancho ojo)
    const R_L = lm[33],  R_R = lm[133];
    const L_L = lm[362], L_R = lm[263];

    // p√°rpados superior/inferior (alto ojo)
    const R_T = lm[159], R_B = lm[145];
    const L_T = lm[386], L_B = lm[374];

    const rW = Math.max(1e-6, Math.abs(R_R.x - R_L.x));
    const lW = Math.max(1e-6, Math.abs(L_R.x - L_L.x));
    const rH = Math.max(1e-6, Math.abs(R_B.y - R_T.y));
    const lH = Math.max(1e-6, Math.abs(L_B.y - L_T.y));

    let rx = (rC.x - Math.min(R_L.x, R_R.x)) / rW;
    let lx = (lC.x - Math.min(L_L.x, L_R.x)) / lW;
    let ry = (rC.y - Math.min(R_T.y, R_B.y)) / rH;
    let ly = (lC.y - Math.min(L_T.y, L_B.y)) / lH;

    // mezcla ojos, inversi√≥n y ganancia (todo en el dominio normalizado)
    let gxN = Math.max(0, Math.min(1, (rx + lx) / 2));
    let gyN = Math.max(0, Math.min(1, (ry + ly) / 2));
    if (CFG.invertX) gxN = 1 - gxN;
    if (CFG.invertY) gyN = 1 - gyN;
    gxN = Math.max(0, Math.min(1, 0.5 + (gxN - 0.5) * CFG.gainX));
    gyN = Math.max(0, Math.min(1, 0.5 + (gyN - 0.5) * CFG.gainY));

    irisN.x = gxN; irisN.y = gyN;

    // Proyecci√≥n por la af√≠n (si existe) y env√≠o al Kalman
    if (A && kalmanReady && irisN.x!=null && irisN.y!=null){
      const px = A[0]*irisN.x + A[1]*irisN.y + b[0];
      const py = A[2]*irisN.x + A[3]*irisN.y + b[1];
      kalmanWorker.postMessage({in:{x:px,y:py,W,H}});
    }

    // Preview de landmarks
    if(preview.style.display!=='none' && CFG.debug){
      pctx.clearRect(0,0,preview.width,preview.height);
      pctx.drawImage(rawVideo,0,0,preview.width,preview.height);
      const toPX = (p) => [p.x*preview.width, p.y*preview.height];
      const draw = (i,c='#0f0',r=3)=>{ const [x,y]=toPX(lm[i]); pctx.fillStyle=c; pctx.beginPath(); pctx.arc(x,y,r,0,Math.PI*2); pctx.fill(); };
      [468,469,470,471,473,474,475,476,13,14,61,291,33,263,159,145,386,374].forEach(i=>draw(i));
      pctx.fillStyle='#fff'; pctx.fillText(`irisN=(${irisN.x?.toFixed(2)||'-'}, ${irisN.y?.toFixed(2)||'-'})`,8,16);
    }
  });

  // ---------- WebGazer fallback (si no Iris) ----------
  if(!CFG.useIris && CFG.controlMode==='eyes'){
    try{
      webgazer.setRegression('ridge'); webgazer.setTracker('TFFacemesh');
      if(webgazer.params){ webgazer.params.showVideoPreview=false; webgazer.params.showFaceFeedbackBox=false; webgazer.params.showPredictionPoints=false; }
      webgazer.begin();
      // Nota: en fallback no hay irisN; usamos p√≠xeles directos (menos preciso)
      webgazer.setGazeListener((data)=>{ if(!data) return; if(kalmanReady){ kalmanWorker.postMessage({in:{x:data.x,y:data.y,W,H}});} });
    }catch(e){ showErr('webgazer init: '+e.message); }
  }

  // ---------- cargar calibraci√≥n ----------
  const saved = loadJson(LS_KEY); if(saved && saved.A && saved.b){ A=saved.A; b=saved.b; }

  // ---------- loop (nariz + boca) ----------
  function loop(){
    if(CFG.controlMode==='nose' && faceBox && nose.x!=null){
      const nxr = (nose.x - faceBox.minx)/Math.max(1e-6, (faceBox.maxx - faceBox.minx));
      const nyr = (nose.y - faceBox.miny)/Math.max(1e-6, (faceBox.maxy - faceBox.miny));
      const tx = nxr * W, ty = nyr * H;
      if(kalmanReady){ kalmanWorker.postMessage({in:{x:tx,y:ty,W,H}}); }
    }
    if(marEma!=null){
      const openThr  = mouthThr + CFG.mouthHys;
      const closeThr = mouthThr - CFG.mouthHys;
      isPainting = isPainting ? (marEma > closeThr) : (marEma > openThr);
    }
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);
  requestAnimationFrame(faceLoop);

  // ---------- recibir filtrado y pintar ----------
  let filtX=null, filtY=null;
  function drawFiltered(x,y){
    let px = Math.max(0, Math.min(W-1, x));
    let py = Math.max(0, Math.min(H-1, y));

    if(CFG.snap?.enabled){
      const s = snapToGrid(px, py, CFG.snap.size, CFG.snap.radius, CFG.snap.blend);
      px = s.x; py = s.y;
    }
    if(anchorsOn && CFG.controlMode==='eyes') applyAnchors(px,py);

    if(mode!=='face'){
      cursor.style.display='block';
      cursor.style.left=px+'px'; cursor.style.top=py+'px';
      cursor.style.width=(brush*2)+'px'; cursor.style.height=(brush*2)+'px';
    } else { cursor.style.display='none'; }

    if(mode==='brush' && isPainting){
      if(filtX!=null){
        ctx.strokeStyle='rgba(0,200,255,.95)'; ctx.lineWidth=brush; ctx.lineJoin='round'; ctx.lineCap='round';
        const cxm=(filtX+px)/2, cym=(filtY+py)/2;
        ctx.beginPath(); ctx.moveTo(filtX,filtY); ctx.quadraticCurveTo(cxm,cym,px,py); ctx.stroke();
        pts.push({t:Date.now(), x:px, y:py, mar:marEma});
        countEl.textContent = `pts: ${pts.length}`;
      }
    }
    filtX=px; filtY=py;
  }

  // ---------- ROI + Calibraci√≥n ----------
  function defineRoiWithMouse(){
    alert('Arrastra con el mouse para dibujar la zona (ROI) donde colocar√© los puntos de calibraci√≥n.');
    const r=stageEl.getBoundingClientRect();
    let start=null, rectEl=null;
    function onDown(e){
      start={x:e.clientX - r.left, y:e.clientY - r.top};
      if(!rectEl){ rectEl=document.createElement('div'); rectEl.className='roi-rect'; roiOverlay.appendChild(rectEl); }
      placeRect(start.x,start.y,1,1);
      window.addEventListener('mousemove',onMove);
      window.addEventListener('mouseup',onUp,{once:true});
    }
    function onMove(e){
      const x=e.clientX - r.left, y=e.clientY - r.top;
      const x0=Math.min(start.x,x), y0=Math.min(start.y,y);
      const x1=Math.max(start.x,x), y1=Math.max(start.y,y);
      placeRect(x0,y0, x1-x0, y1-y0);
    }
    function onUp(){
      window.removeEventListener('mousemove',onMove);
      const bb=roiOverlay.lastChild.getBoundingClientRect();
      const x0=(bb.left - r.left)/r.width, y0=(bb.top - r.top)/r.height;
      const x1=(bb.right - r.left)/r.width, y1=(bb.bottom - r.top)/r.height;
      roiNorm = {x0:clamp01(x0), y0:clamp01(y0), x1:clamp01(x1), y1:clamp01(y1)};
      saveJson(ROI_KEY, roiNorm); drawRoiRect();
      alert('ROI guardada. Ejecuta la calibraci√≥n guiada.');
    }
    stageEl.addEventListener('mousedown',onDown,{once:true});
    function placeRect(x,y,w,h){ const el=roiOverlay.lastChild; el.style.left=x+'px'; el.style.top=y+'px'; el.style.width=w+'px'; el.style.height=h+'px'; }
  }
  function drawRoiRect(){
    roiOverlay.innerHTML='';
    const r=stageEl.getBoundingClientRect();
    const x0=roiNorm.x0*r.width, y0=roiNorm.y0*r.height;
    const w =(roiNorm.x1-roiNorm.x0)*r.width;
    const h =(roiNorm.y1-roiNorm.y0)*r.height;
    const rectEl=document.createElement('div');
    rectEl.className='roi-rect';
    rectEl.style.left=x0+'px'; rectEl.style.top=y0+'px';
    rectEl.style.width=w+'px'; rectEl.style.height=h+'px';
    roiOverlay.appendChild(rectEl);
  }

  async function guidedRoiCalibration(){
    if(CFG.controlMode!=='eyes'){ alert('La calibraci√≥n aplica al control por OJOS. Cambia ‚ÄúMover brocha con‚Äù a OJOS.'); return; }
    const r=stageEl.getBoundingClientRect();
    const rx0=roiNorm.x0*r.width, ry0=roiNorm.y0*r.height;
    const rw =(roiNorm.x1-roiNorm.x0)*r.width;
    const rh =(roiNorm.y1-roiNorm.y0)*r.height;

    const nx=[0,0.5,1], ny=[0,0.5,1];
    const targets=[]; for(const ix of nx) for(const iy of ny){ targets.push({ x: rx0 + ix*rw, y: ry0 + iy*rh }); }

    roiOverlay.innerHTML=''; drawRoiRect();
    const els=[];
    for(const t of targets){
      const el=document.createElement('div'); el.className='calib-target wait';
      el.style.left=t.x+'px'; el.style.top=t.y+'px';
      roiOverlay.appendChild(el); els.push(el);
    }

    alert('Calibraci√≥n: clic en cada punto y MIRA ese punto ~1.2s.\n(Se aprende A,b: irisN‚Üíp√≠xeles)');
    const normPts=[], tgtPts=[];
    for(let i=0;i<targets.length;i++){
      const el=els[i]; const t=targets[i];
      await new Promise(res=>{
        const onceClick = async ()=>{
          el.classList.remove('wait'); el.classList.add('calib-target');
          const samples=[]; const t0=performance.now();
          function step(){
            const now=performance.now();
            if(irisN.x!=null && irisN.y!=null){ samples.push([irisN.x, irisN.y]); }
            if(now-t0<1200){ requestAnimationFrame(step); }
            else{
              const m=mean2(samples);
              if(!isNaN(m[0])){ normPts.push(m); tgtPts.push([t.x, t.y]); }
              el.classList.add('done'); res();
            }
          }
          requestAnimationFrame(step);
        };
        el.addEventListener('click', onceClick, {once:true});
      });
      await sleep(120);
    }
    const sol=lsqAffine(normPts, tgtPts);
    if(sol){ A=sol.A; b=sol.b; saveJson(LS_KEY,{A,b}); alert('‚úÖ Calibraci√≥n guardada (irisN‚Üíp√≠xeles).'); }
    else{ alert('No se pudo calibrar (muestras insuficientes).'); }
  }

  // ---------- anclas & snap ----------
  function getAnchors(){
    const r=stageEl.getBoundingClientRect();
    const rx0=roiNorm.x0*r.width, ry0=roiNorm.y0*r.height;
    const rw =(roiNorm.x1-roiNorm.x0)*r.width;
    const rh =(roiNorm.y1-roiNorm.y0)*r.height;
    return [
      {x:rx0,        y:ry0       },
      {x:rx0+rw,     y:ry0       },
      {x:rx0+rw,     y:ry0+rh    },
      {x:rx0,        y:ry0+rh    },
      {x:rx0+rw/2,   y:ry0+rh/2  }
    ];
  }
  function applyAnchors(px,py){
    const APTS=getAnchors();
    let best=null, bd=1e9;
    for(const p of APTS){ const d=Math.hypot(p.x-px,p.y-py); if(d<bd){bd=d; best=p;} }
    if(bd <= CFG.anchors.radiusPx){
      if(currentAnchor!==best){ currentAnchor=best; dwellStart=performance.now(); }
      else{
        const dt=performance.now()-dwellStart;
        if(dt >= CFG.anchors.dwellMs){
          // peque√±o ajuste al sesgo b para ‚Äúrecapturar‚Äù el centro
          b[0] += (best.x - px) * CFG.anchors.adjust;
          b[1] += (best.y - py) * CFG.anchors.adjust;
          saveJson(LS_KEY,{A,b});
          dwellStart = performance.now();
        }
      }
    }else{ currentAnchor=null; dwellStart=null; }
  }
  function snapToGrid(x,y,G,R,B){
    const gx = Math.round(x/G)*G, gy = Math.round(y/G)*G;
    const d = Math.hypot(gx-x, gy-y);
    if(d<=R){ return {x:(1-B)*x+B*gx, y:(1-B)*y+B*gy}; }
    return {x,y};
  }

  // ---------- utils ----------
  function sleep(ms){return new Promise(r=>setTimeout(r,ms));}
  function mean2(a){if(!a.length)return[NaN,NaN];const sx=a.reduce((s,v)=>s+v[0],0), sy=a.reduce((s,v)=>s+v[1],0);return[sx/a.length, sy/a.length];}
  function median(arr){ if(!arr.length) return NaN; const a=[...arr].sort((x,y)=>x-y), m=Math.floor(a.length/2); return a.length%2 ? a[m] : (a[m-1]+a[m])/2; }
  function clamp01(v){return Math.max(0,Math.min(1,v));}
  function transpose(A){const m=A.length,n=A[0].length,AT=Array.from({length:n},()=>Array(m).fill(0));for(let i=0;i<m;i++)for(let j=0;j<n;j++)AT[j][i]=A[i][j];return AT;}
  function mul(A,B){const m=A.length,n=A[0].length,p=B[0].length,C=Array.from({length:m},()=>Array(p).fill(0));for(let i=0;i<m;i++)for(let k=0;k<n;k++)for(let j=0;j<p;j++)C[i][j]+=A[i][k]*B[k][j];return C;}
  function mulVec(A,v){const m=A.length,n=A[0].length,r=Array(m).fill(0);for(let i=0;i<m;i++)for(let j=0;j<n;j++)r[i]+=A[i][j]*v[j];return r;}
  function solveGaussian(A,b){const n=A.length,M=A.map((row,i)=>row.concat([b[i]]));for(let i=0;i<n;i++){let max=i;for(let r=i+1;r<n;r++)if(Math.abs(M[r][i])>Math.abs(M[max][i]))max=r;if(Math.abs(M[max][i])<1e-9)return null;[M[i],M[max]]=[M[max],M[i]];const piv=M[i][i];for(let k=i;k<=n;k++)M[i][k]/=piv;for(let r=0;r<n;r++)if(r!==i){const f=M[r][i];for(let k=i;k<=n;k++)M[r][k]-=f*M[i][k];}}return M.map(row=>row[n]);}
  function lsqAffine(srcPts,dstPts){
    if(!srcPts.length || srcPts.length<3) return null;
    const M=[],Z=[];
    for(let i=0;i<srcPts.length;i++){
      const[gx,gy]=srcPts[i]; const[tx,ty]=dstPts[i];
      M.push([gx,gy,0,0,1,0]); Z.push(tx);
      M.push([0,0,gx,gy,0,1]); Z.push(ty);
    }
    const Mt=transpose(M),MtM=mul(Mt,M),MtZ=mulVec(Mt,Z),p=solveGaussian(MtM,MtZ);
    return p?{A:[p[0],p[1],p[2],p[3]],b:[p[4],p[5]]}:null;
  }
  function saveJson(k,v){ try{ localStorage.setItem(k, JSON.stringify(v)); }catch(e){} }
  function loadJson(k){ try{ const s=localStorage.getItem(k); return s?JSON.parse(s):null; }catch(e){ return null; } }

  // ---------- Worker Kalman ----------
  function makeKalmanWorker(){
    const code = `
      let ready=false, cfg={procNoise:1e-2, measNoise:2.0, maxStep:22, deadzone:6};
      class Kal2D{
        constructor(q=1e-2,r=2.0,dt=1/60){
          this.dt=dt; this.q=q; this.r=r;
          this.x=[0,0,0,0];
          this.P=[1,0,0,0, 0,1,0,0, 0,0,10,0, 0,0,0,10];
          this.H=[1,0,0,0, 0,1,0,0];
          this.R=[r,0, 0,r];
        }
        predict(){
          const dt=this.dt;
          const F=[1,0,dt,0, 0,1,0,dt, 0,0,1,0, 0,0,0,1];
          const Q=[cfg.procNoise,0,0,0, 0,cfg.procNoise,0,0, 0,0,1e-3,0, 0,0,0,1e-3];
          const P=this.P;
          this.x=[ F[0]*this.x[0]+F[2]*this.x[2], F[5]*this.x[1]+F[7]*this.x[3], this.x[2], this.x[3] ];
          const FP=new Array(16).fill(0);
          for(let i=0;i<4;i++)for(let j=0;j<4;j++)for(let k=0;k<4;k++) FP[i*4+j]+=F[i*4+k]*P[k*4+j];
          const FPt=new Array(16).fill(0);
          for(let i=0;i<4;i++)for(let j=0;j<4;j++)for(let k=0;k<4;k++) FPt[i*4+j]+=FP[i*4+k]*F[j*4+k];
          this.P=FPt.map((v,i)=>v+Q[i]);
        }
        update(zx,zy){
          const yx = zx - this.x[0];
          const yy = zy - this.x[1];
          const Kx = 0.25, Ky = 0.25; // simple ganancia (suficiente aqu√≠)
          this.x[0]+=Kx*yx; this.x[1]+=Ky*yy;
        }
      }
      const kf=new Kal2D();
      self.postMessage({ready:true});
      self.onmessage=(e)=>{
        if(e.data?.cfg){ Object.assign({},e.data.cfg); return; }
        if(e.data?.in){
          const {x,y}=e.data.in;
          kf.predict(); kf.update(x,y);
          self.postMessage({out:{x:kf.x[0], y:kf.x[1]}});
        }
      };
    `;
    const blob=new Blob([code],{type:'application/javascript'});
    const url=URL.createObjectURL(blob);
    return new Worker(url);
  }

})();
</script>
</body>
</html>
