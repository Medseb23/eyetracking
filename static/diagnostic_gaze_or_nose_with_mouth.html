<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Brocha Ocular</title>

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh"></script>

<style>
  html, body { margin:0; padding:0; height:100%; overflow:hidden; background:#0f1115; color:#fff; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif }
  #wrap { position:relative; width:100%; height:100vh }
  #topbar { position:absolute; top:10px; left:10px; right:10px; display:flex; gap:8px; flex-wrap:wrap; background:rgba(0,0,0,.45); padding:8px 10px; border-radius:10px; align-items:center; z-index:10000; box-shadow: 0 4px 6px rgba(0,0,0,.15) }
  .btn { appearance:none; border:0; padding:8px 14px; border-radius:10px; cursor:pointer; background:#2b2f3a; color:#fff; font-weight:600; transition: background .2s, transform .1s; }
  .btn:hover { background: #3b424f; }
  .btn:active { transform: scale(0.98); }
  .btn.primary { background:#00e676; color:#111; }
  .btn.primary:hover { background: #00c853; }
  .btn.warn { background:#ff5252; }
  .btn.warn:hover { background: #e04545; }
  .sp { margin-left:auto; font:12px/1.2 monospace; opacity:.9 }
  #stage { position:absolute; inset:62px 10px 10px 10px; border-radius:10px; background:#10131a; overflow:hidden; box-shadow: 0 4px 6px rgba(0,0,0,.15); }
  #canvas { position:absolute; inset:0; width:100%; height:100% }
  #cursor { position:absolute; width:20px; height:20px; border:3px solid rgba(255,255,255,.95); border-radius:50%; pointer-events:none; transform:translate(-50%,-50%); display:none; transition: all .05s ease-out; }
  #status { position:absolute; bottom:10px; left:10px; right:10px; display:flex; gap:10px; align-items:center; background:rgba(255,255,255,.06); padding:8px 10px; border-radius:10px; z-index:9999; box-shadow: 0 -2px 4px rgba(0,0,0,.1) }
  #modeTag { font-weight:700; background:#1f2937; padding:4px 8px; border-radius:8px }
  #marPanel { display:flex; align-items:center; gap:8px; flex:1 }
  #marBar { position:relative; height:12px; flex:1; background:#2b2f3a; border-radius:6px; overflow:hidden }
  #marFill { position:absolute; top:0; left:0; height:100%; width:0%; background:#00e676; transition: width .1s ease-out; }
  #marThr { position:absolute; top:-3px; width:2px; height:18px; background:#ff5252; left:50% }
  #marVal { min-width:140px; text-align:right; font:12px/1 monospace; opacity:.9 }
  #dbg { position:absolute; right:10px; bottom:10px; background:rgba(0,0,0,.55); padding:6px 8px; border-radius:8px; font:12px/1.2 monospace; opacity: .8 }
  video#rawVideo { display:none }
  #errbar { position:absolute; top:0; left:0; right:0; background:#ff3344; color:#100; padding:6px 10px; font:12px/1.3 monospace; display:none; z-index:10001; text-align: center; }
  .roi-overlay { position:absolute; inset:0; pointer-events:none }
  .roi-rect { position:absolute; border:2px dashed rgba(0,230,118,.9); border-radius:8px; box-shadow:0 0 0 200vmax rgba(0,0,0,.45) inset; transition: all .3s }
  .calib-target { position:absolute; width:18px; height:18px; border-radius:50%; background:#00e676; box-shadow:0 0 0 6px rgba(0,230,118,.2); transform:translate(-50%,-50%); pointer-events:auto; cursor:crosshair; transition: all .3s }
  .calib-target.wait { background:#fbbf24; box-shadow:0 0 0 6px rgba(251,191,36,.25); }
  .calib-target.done { background:#22d3ee; box-shadow:0 0 0 6px rgba(34,211,238,.25); }
</style>
</head>
<body>
<div id="wrap">
  <div id="topbar">
    <button id="testCam" class="btn primary">Iniciar</button>
    <button id="btnCalib" class="btn">1) Calibrar Mirada</button>
    <button id="btnStart" class="btn">2) Iniciar Brocha</button>
    <button id="btnClear" class="btn warn">üßπ Limpiar</button>
    <button id="btnResetCal" class="btn">‚ôªÔ∏è Reset Calibraci√≥n</button>
    <span class="sp" id="count">pts: 0</span>
  </div>

  <div id="stage">
    <canvas id="canvas"></canvas>
    <div id="cursor"></div>
    <div class="roi-overlay" id="roiOverlay"></div>
    <div id="dbg" style="display:none"></div>
    <video id="rawVideo" playsinline autoplay muted></video>
  </div>

  <div id="status">
    <span id="modeTag">Modo: Esperando</span>
    <div id="marPanel">
      <span>MAR:</span>
      <div id="marBar"><div id="marFill"></div><div id="marThr"></div></div>
      <span id="marVal">‚Äî</span>
    </div>
  </div>

  <div id="errbar"></div>
</div>

<script>
(function(){
  // --- Estado de la aplicaci√≥n ---
  let mode = 'idle'; // 'idle', 'calibrating', 'brush'
  let isPainting = false;
  let hasCalib = false;
  let A = [1,0,0,1], b = [0,0]; // Matriz de transformaci√≥n af√≠n
  const LS_CALIB_KEY = 'brocha_calib_affine';
  
  // --- Configuraci√≥n (ajustable) ---
  const CFG = {
    brush: 12,
    mouthThr: 0.28,
    mouthHys: 0.05,
    marMedianN: 5,
    marEmaAlpha: 0.30,
    gainX: 1.15, gainY: 1.15,
    invertY: true,
  };

  // --- Elementos del DOM ---
  const errbar = document.getElementById('errbar');
  const stageEl = document.getElementById('stage');
  const canvas = document.getElementById('canvas'); const ctx = canvas.getContext('2d');
  const cursor = document.getElementById('cursor');
  const rawVideo = document.getElementById('rawVideo');
  const countEl = document.getElementById('count');
  const modeTag = document.getElementById('modeTag');
  const marVal = document.getElementById('marVal');
  const marFill = document.getElementById('marFill');
  const marThr = document.getElementById('marThr');
  const roiOverlay = document.getElementById('roiOverlay');

  // --- Se√±ales y datos ---
  let W, H;
  let irisN = {x: null, y: null};
  let marEma = null;
  let lastPoint = null;
  let drawingPoints = [];

  // --- Funciones de Utilidad ---
  function showErr(msg) { errbar.textContent = `‚ö†Ô∏è ${msg}`; errbar.style.display = 'block'; }
  function showInfo(msg) { errbar.textContent = `‚ÑπÔ∏è ${msg}`; errbar.style.display = 'block'; }
  function hideErr() { errbar.style.display = 'none'; }
  function median(arr) { if(!arr.length) return NaN; const a=[...arr].sort((x,y)=>x-y), m=Math.floor(a.length/2); return a.length%2 ? a[m] : (a[m-1]+a[m])/2; }
  function dist2(a, b) { return Math.hypot(a.x - b.x, a.y - b.y); }
  function saveJson(k, v) { try { if(v == null) localStorage.removeItem(k); else localStorage.setItem(k, JSON.stringify(v)); } catch(e) {} }
  function loadJson(k) { try { const s = localStorage.getItem(k); return s ? JSON.parse(s) : null; } catch(e) { return null; } }
  function sleep(ms) { return new Promise(res => setTimeout(res, ms)); }
  function lsqAffine(src, dst) {
    if (src.length < 3) return null;
    const M = [];
    const Z = [];
    for (let i = 0; i < src.length; i++) {
      const [gx, gy] = src[i];
      const [tx, ty] = dst[i];
      M.push([gx, gy, 0, 0, 1, 0]);
      Z.push(tx);
      M.push([0, 0, gx, gy, 0, 1]);
      Z.push(ty);
    }
    const transpose = (A) => A[0].map((_, c) => A.map(r => r[c]));
    const mul = (A, B) => A.map(r => B[0].map((_, c) => r.reduce((s, e, i) => s + e * B[i][c], 0)));
    const solve = (A, b) => {
      const n = b.length;
      for (let i = 0; i < n; i++) {
        let maxRow = i;
        for (let k = i + 1; k < n; k++) if (Math.abs(A[k][i]) > Math.abs(A[maxRow][i])) maxRow = k;
        [A[i], A[maxRow]] = [A[maxRow], A[i]];
        const pivot = A[i][i];
        if (Math.abs(pivot) < 1e-9) return null;
        for (let k = i; k < n; k++) A[i][k] /= pivot;
        b[i] /= pivot;
        for (let k = 0; k < n; k++) {
          if (k !== i) {
            const factor = A[k][i];
            for (let j = i; j < n; j++) A[k][j] -= factor * A[i][j];
            b[k] -= factor * b[i];
          }
        }
      }
      return b;
    };
    const Mt = transpose(M);
    const MtM = mul(Mt, M);
    const MtZ = Mt.map(row => row.reduce((sum, val, i) => sum + val * Z[i], 0));
    const p = solve(MtM, MtZ);
    return p ? {A:[p[0],p[1],p[2],p[3]], b:[p[4],p[5]]} : null;
  }

  // --- Inicializaci√≥n y Redimensionamiento ---
  function resize() {
    const dpr = window.devicePixelRatio || 1;
    const r = stageEl.getBoundingClientRect();
    W = r.width; H = r.height;
    canvas.width = Math.floor(W * dpr); canvas.height = Math.floor(H * dpr);
    canvas.style.width = W + 'px'; canvas.style.height = H + 'px';
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  window.addEventListener('resize', resize); resize();

  // --- L√≥gica del Gesto de la Boca (MAR) ---
  const marHist = [];
  function processMouth(landmarks) {
    const mouthH = dist2(landmarks[13], landmarks[14]);
    const mouthW = dist2(landmarks[61], landmarks[291]);
    const marRaw = mouthH / Math.max(1e-6, mouthW);
    marHist.push(marRaw);
    if (marHist.length > CFG.marMedianN) marHist.shift();
    const med = median(marHist);
    marEma = marEma == null ? med : CFG.marEmaAlpha * med + (1 - CFG.marEmaAlpha) * marEma;
    const marUi = Math.max(0, Math.min(0.8, marEma));
    marVal.textContent = `raw: ${marRaw.toFixed(3)} | filt: ${marEma.toFixed(3)}`;
    marFill.style.width = (marUi / 0.8 * 100).toFixed(0) + '%';
    marThr.style.left = (Math.max(0, Math.min(1, CFG.mouthThr / 0.8)) * 100).toFixed(0) + '%';
    
    const openThr = CFG.mouthThr + CFG.mouthHys;
    const closeThr = CFG.mouthThr - CFG.mouthHys;
    isPainting = isPainting ? (marEma > closeThr) : (marEma > openThr);
  }

  // --- L√≥gica de la Mirada (Iris) ---
  function processGaze(landmarks) {
    const avg = (idxs) => idxs.reduce((s,i)=>({x:s.x+landmarks[i].x, y:s.y+landmarks[i].y}), {x:0,y:0});
    const rC = avg([468,469,470,471]); rC.x/=4; rC.y/=4;
    const lC = avg([473,474,475,476]); lC.x/=4; lC.y/=4;
    const R_L = landmarks[133], R_R = landmarks[33];
    const R_T = landmarks[159], R_B = landmarks[145];
    const L_L = landmarks[362], L_R = landmarks[263];
    const L_T = landmarks[386], L_B = landmarks[374];
    const rW = Math.abs(R_R.x - R_L.x), lW = Math.abs(L_R.x - L_L.x);
    const rH = Math.abs(R_B.y - R_T.y), lH = Math.abs(L_B.y - L_T.y);
    const rx = (rC.x - R_L.x) / rW, lx = (lC.x - L_L.x) / lW;
    const ry = (rC.y - R_T.y) / rH, ly = (lC.y - L_T.y) / lH;
    let gxN = (rx + lx) / 2;
    let gyN = (ry + ly) / 2;
    if (CFG.invertY) gyN = 1 - gyN;
    gxN = Math.max(0, Math.min(1, 0.5 + (gxN - 0.5) * CFG.gainX));
    gyN = Math.max(0, Math.min(1, 0.5 + (gyN - 0.5) * CFG.gainY));
    irisN.x = gxN;
    irisN.y = gyN;
  }

  // --- Detecci√≥n de Rostros y Bucle Principal ---
  const faceMesh = new FaceMesh({ locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${f}` });
  faceMesh.setOptions({ maxNumFaces: 1, refineLandmarks: true, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
  faceMesh.onResults(results => {
    if (!results.multiFaceLandmarks || results.multiFaceLandmarks.length === 0) {
      cursor.style.display = 'none';
      return;
    }
    const lm = results.multiFaceLandmarks[0];
    processMouth(lm);
    processGaze(lm);

    let px, py;
    if (hasCalib) {
      px = A[0] * irisN.x + A[1] * irisN.y + b[0];
      py = A[2] * irisN.x + A[3] * irisN.y + b[1];
    } else {
      px = irisN.x * W;
      py = irisN.y * H;
    }

    const x = Math.max(0, Math.min(W, px));
    const y = Math.max(0, Math.min(H, py));

    if (mode === 'brush' || mode === 'calibrating') {
      cursor.style.display = 'block';
      cursor.style.left = x + 'px';
      cursor.style.top = y + 'px';
      if (mode === 'brush' && isPainting) {
        if (lastPoint) {
          ctx.strokeStyle = 'rgba(0,200,255,.95)'; ctx.lineWidth = CFG.brush; ctx.lineJoin = 'round'; ctx.lineCap = 'round';
          ctx.beginPath();
          ctx.moveTo(lastPoint.x, lastPoint.y);
          ctx.lineTo(x, y);
          ctx.stroke();
          drawingPoints.push({ x: x, y: y, mar: marEma, t: Date.now() });
          countEl.textContent = `pts: ${drawingPoints.length}`;
        }
        lastPoint = { x, y };
      } else {
        lastPoint = { x, y };
      }
    } else {
      cursor.style.display = 'none';
      lastPoint = null;
    }
  });

  async function startCamera() {
    if (rawVideo.srcObject) return;
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ video: { width: { ideal:1280 }, height: { ideal:720 }, facingMode:"user" } });
      rawVideo.srcObject = stream;
      await rawVideo.play();
      hideErr();
      requestAnimationFrame(faceLoop);
      showInfo('C√°mara lista. Por favor, calibra tu mirada.');
    } catch (e) {
      showErr(`No se pudo acceder a la c√°mara. ${e.name}: ${e.message}`);
    }
  }

  async function faceLoop() {
    if (rawVideo.readyState >= 2 && !rawVideo.paused && !rawVideo.ended) {
      await faceMesh.send({ image: rawVideo });
    }
    requestAnimationFrame(faceLoop);
  }

  // --- Calibraci√≥n Guiada (UI) ---
  const calibTargets = [];
  function setupCalibration() {
    mode = 'calibrating';
    modeTag.textContent = 'Modo: Calibrando';
    roiOverlay.innerHTML = '';
    const numTargets = 9;
    const grid = Math.sqrt(numTargets);
    const gap = 1 / (grid + 1);
    for (let i = 0; i < numTargets; i++) {
      const x = (i % grid + 1) * gap;
      const y = (Math.floor(i / grid) + 1) * gap;
      const targetEl = document.createElement('div');
      targetEl.className = 'calib-target wait';
      targetEl.style.left = (x * 100) + '%';
      targetEl.style.top = (y * 100) + '%';
      roiOverlay.appendChild(targetEl);
      calibTargets.push({ el: targetEl, x: x * W, y: y * H, samples: [] });
    }
    showInfo('Calibraci√≥n: Mira el punto que aparece y haz clic en √©l. Repite para cada punto.');
    startCalibrationFlow();
  }

  async function startCalibrationFlow() {
    const src = [], dst = [];
    for (const target of calibTargets) {
      await new Promise(res => {
        target.el.addEventListener('click', () => {
          target.el.classList.remove('wait');
          const t0 = performance.now();
          const collectSamples = () => {
            if (irisN.x !== null) {
              target.samples.push([irisN.x, irisN.y]);
            }
            if (performance.now() - t0 < 1000) {
              requestAnimationFrame(collectSamples);
            } else {
              const meanSample = target.samples.reduce((sum, p) => [sum[0] + p[0], sum[1] + p[1]], [0, 0]).map(v => v / target.samples.length);
              if (!isNaN(meanSample[0])) {
                src.push(meanSample);
                dst.push([target.x, target.y]);
              }
              target.el.classList.add('done');
              res();
            }
          };
          collectSamples();
        }, { once: true });
      });
      await sleep(200);
    }
    const sol = lsqAffine(src, dst);
    if (sol) {
      A = sol.A;
      b = sol.b;
      hasCalib = true;
      saveJson(LS_CALIB_KEY, { A, b });
      showInfo('‚úÖ Calibraci√≥n completada y guardada. ¬°Ahora puedes iniciar la brocha!');
    } else {
      showErr('‚ùå Fall√≥ la calibraci√≥n. Aseg√∫rate de mirar directamente a cada punto.');
    }
    roiOverlay.innerHTML = '';
  }

  // --- Eventos de Botones ---
  document.getElementById('testCam').onclick = startCamera;
  document.getElementById('btnCalib').onclick = setupCalibration;
  document.getElementById('btnStart').onclick = () => {
    if (!hasCalib) {
      showErr('Debes calibrar la mirada primero.');
      return;
    }
    mode = 'brush';
    modeTag.textContent = 'Modo: Brocha';
    showInfo('¬°Mueve tus ojos para dibujar! Abre la boca para activar la brocha.');
    roiOverlay.innerHTML = '';
  };
  document.getElementById('btnClear').onclick = () => {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawingPoints = [];
    countEl.textContent = 'pts: 0';
  };
  document.getElementById('btnResetCal').onclick = () => {
    hasCalib = false;
    saveJson(LS_CALIB_KEY, null);
    showInfo('Calibraci√≥n reiniciada. Por favor, calibra de nuevo.');
  };

  // --- Cargar calibraci√≥n al inicio ---
  const savedCalib = loadJson(LS_CALIB_KEY);
  if (savedCalib) {
    A = savedCalib.A;
    b = savedCalib.b;
    hasCalib = true;
    showInfo('Calibraci√≥n anterior cargada. Puedes iniciar la brocha directamente.');
  }

})();
</script>
</body>
</html>
