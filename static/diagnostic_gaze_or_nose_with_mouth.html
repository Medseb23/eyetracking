<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Brocha Ocular</title>

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh"></script>

<style>
  html, body { margin:0; padding:0; height:100%; overflow:hidden; background:#0f1115; color:#fff; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif }
  #wrap { position:relative; width:100%; height:100vh }
  #topbar { position:absolute; top:10px; left:10px; right:10px; display:flex; gap:8px; flex-wrap:wrap; background:rgba(0,0,0,.45); padding:8px 10px; border-radius:10px; align-items:center; z-index:10000; box-shadow: 0 4px 6px rgba(0,0,0,.15) }
  .btn { appearance:none; border:0; padding:8px 14px; border-radius:10px; cursor:pointer; background:#2b2f3a; color:#fff; font-weight:600; transition: background .2s, transform .1s; }
  .btn:hover { background: #3b424f; }
  .btn:active { transform: scale(0.98); }
  .btn.primary { background:#00e676; color:#111; }
  .btn.primary:hover { background: #00c853; }
  .btn.warn { background:#ff5252; }
  .btn.warn:hover { background: #e04545; }
  .sp { margin-left:auto; font:12px/1.2 monospace; opacity:.9 }
  #stage { position:absolute; inset:62px 10px 10px 10px; border-radius:10px; background:#10131a; overflow:hidden; box-shadow: 0 4px 6px rgba(0,0,0,.15); }
  #canvas { position:absolute; inset:0; width:100%; height:100% }
  #cursor { position:absolute; width:20px; height:20px; border:3px solid rgba(255,255,255,.95); border-radius:50%; pointer-events:none; transform:translate(-50%,-50%); display:none; transition: all .05s ease-out; }
  #status { position:absolute; bottom:10px; left:10px; right:10px; display:flex; gap:10px; align-items:center; background:rgba(255,255,255,.06); padding:8px 10px; border-radius:10px; z-index:9999; box-shadow: 0 -2px 4px rgba(0,0,0,.1) }
  #modeTag { font-weight:700; background:#1f2937; padding:4px 8px; border-radius:8px }
  #marPanel { display:flex; align-items:center; gap:8px; flex:1 }
  #marBar { position:relative; height:12px; flex:1; background:#2b2f3a; border-radius:6px; overflow:hidden }
  #marFill { position:absolute; top:0; left:0; height:100%; width:0%; background:#00e676; transition: width .1s ease-out; }
  #marThr { position:absolute; top:-3px; width:2px; height:18px; background:#ff5252; left:50% }
  #marVal { min-width:140px; text-align:right; font:12px/1 monospace; opacity:.9 }
  #dbg { position:absolute; right:10px; bottom:10px; background:rgba(0,0,0,.55); padding:6px 8px; border-radius:8px; font:12px/1.2 monospace; opacity: .8 }
  video#rawVideo { display:none }
  #errbar { position:absolute; top:0; left:0; right:0; background:#ff3344; color:#100; padding:6px 10px; font:12px/1.3 monospace; display:none; z-index:10001; text-align: center; }
  .calib-step-ui { position:absolute; inset:0; display:flex; flex-direction:column; justify-content:center; align-items:center; background:rgba(0,0,0,0.7); z-index:100; }
  .calib-step-ui h2 { margin:0; padding:10px; font-size: 2em; }
  .calib-step-ui p { margin:5px 0 20px; font-size: 1.2em; max-width: 600px; text-align: center; }
  .calib-point { position:absolute; width:20px; height:20px; border:2px solid #fff; border-radius:50%; transform:translate(-50%,-50%); transition: all .3s ease-out; }
</style>
</head>
<body>
<div id="wrap">
  <div id="topbar">
    <button id="testCam" class="btn primary">Iniciar CÃ¡mara</button>
    <button id="btnCalibrate" class="btn">Calibrar Mirada</button>
    <button id="btnStart" class="btn">Iniciar Brocha</button>
    <button id="btnClear" class="btn warn">ðŸ§¹ Limpiar</button>
    <span class="sp" id="count">pts: 0</span>
  </div>

  <div id="stage">
    <canvas id="canvas"></canvas>
    <div id="cursor"></div>
    <div id="calibUI" class="calib-step-ui" style="display: none;">
      <h2 id="calibTitle"></h2>
      <p id="calibDescription"></p>
    </div>
    <div id="dbg" style="display:none"></div>
    <video id="rawVideo" playsinline autoplay muted></video>
  </div>

  <div id="status">
    <span id="modeTag">Modo: Esperando</span>
    <div id="marPanel">
      <span>MAR:</span>
      <div id="marBar"><div id="marFill"></div><div id="marThr"></div></div>
      <span id="marVal">â€”</span>
    </div>
  </div>

  <div id="errbar"></div>
</div>

<script>
(function(){
  // --- Estado de la aplicaciÃ³n ---
  let mode = 'idle'; // 'idle', 'calibrating_center', 'calibrating_limits', 'brush'
  let isPainting = false;
  
  // --- ConfiguraciÃ³n (ajustable) ---
  const CFG = {
    brush: 12,
    mouthThr: 0.28,
    mouthHys: 0.05,
    marMedianN: 5,
    marEmaAlpha: 0.30,
    // Coordenadas de calibraciÃ³n para centrar el iris
    calib_center: {x: 0.5, y: 0.5},
    // Ganancia y Offset para el mapeo
    offset: {x: 0, y: 0},
    scale: {x: 1, y: 1},
    invertY: true,
  };

  // --- Elementos del DOM ---
  const errbar = document.getElementById('errbar');
  const stageEl = document.getElementById('stage');
  const canvas = document.getElementById('canvas'); const ctx = canvas.getContext('2d');
  const cursor = document.getElementById('cursor');
  const rawVideo = document.getElementById('rawVideo');
  const countEl = document.getElementById('count');
  const modeTag = document.getElementById('modeTag');
  const marVal = document.getElementById('marVal');
  const marFill = document.getElementById('marFill');
  const marThr = document.getElementById('marThr');
  const calibUI = document.getElementById('calibUI');
  const calibTitle = document.getElementById('calibTitle');
  const calibDescription = document.getElementById('calibDescription');

  // --- SeÃ±ales y datos ---
  let W, H;
  let irisN = {x: null, y: null};
  let marEma = null;
  let lastPoint = null;
  let drawingPoints = [];
  let calibrationPoints = {
      center: null,
      left: null,
      right: null,
      up: null,
      down: null
  };
  let calib_step = 0;

  // --- Funciones de Utilidad ---
  function showErr(msg) { errbar.textContent = `âš ï¸ ${msg}`; errbar.style.display = 'block'; }
  function showInfo(msg) { errbar.textContent = `â„¹ï¸ ${msg}`; errbar.style.display = 'block'; }
  function hideErr() { errbar.style.display = 'none'; }
  function median(arr) { if(!arr.length) return NaN; const a=[...arr].sort((x,y)=>x-y), m=Math.floor(a.length/2); return a.length%2 ? a[m] : (a[m-1]+a[m])/2; }
  function dist2(a, b) { return Math.hypot(a.x - b.x, a.y - b.y); }

  // --- InicializaciÃ³n y Redimensionamiento ---
  function resize() {
    const dpr = window.devicePixelRatio || 1;
    const r = stageEl.getBoundingClientRect();
    W = r.width; H = r.height;
    canvas.width = Math.floor(W * dpr); canvas.height = Math.floor(H * dpr);
    canvas.style.width = W + 'px'; canvas.style.height = H + 'px';
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  window.addEventListener('resize', resize); resize();

  // --- LÃ³gica del Gesto de la Boca (MAR) ---
  const marHist = [];
  function processMouth(landmarks) {
    const mouthH = dist2(landmarks[13], landmarks[14]);
    const mouthW = dist2(landmarks[61], landmarks[291]);
    const marRaw = mouthH / Math.max(1e-6, mouthW);
    marHist.push(marRaw);
    if (marHist.length > CFG.marMedianN) marHist.shift();
    const med = median(marHist);
    marEma = marEma == null ? med : CFG.marEmaAlpha * med + (1 - CFG.marEmaAlpha) * marEma;
    const marUi = Math.max(0, Math.min(0.8, marEma));
    marVal.textContent = `raw: ${marRaw.toFixed(3)} | filt: ${marEma.toFixed(3)}`;
    marFill.style.width = (marUi / 0.8 * 100).toFixed(0) + '%';
    marThr.style.left = (Math.max(0, Math.min(1, CFG.mouthThr / 0.8)) * 100).toFixed(0) + '%';
    
    const openThr = CFG.mouthThr + CFG.mouthHys;
    const closeThr = CFG.mouthThr - CFG.mouthHys;
    isPainting = isPainting ? (marEma > closeThr) : (marEma > openThr);
  }

  // --- LÃ³gica de la Mirada (Iris) ---
  function processGaze(landmarks) {
    const avg = (idxs) => idxs.reduce((s, i) => ({ x: s.x + landmarks[i].x, y: s.y + landmarks[i].y }), { x: 0, y: 0 });
    const rC = avg([468, 469, 470, 471]); rC.x /= 4; rC.y /= 4;
    const lC = avg([473, 474, 475, 476]); lC.x /= 4; lC.y /= 4;

    const R_L = landmarks[133], R_R = landmarks[33];
    const L_L = landmarks[362], L_R = landmarks[263];

    const rW = Math.abs(R_R.x - R_L.x), lW = Math.abs(L_R.x - L_L.x);
    
    let irisX_norm;
    let irisY_norm;

    if (rW > 0 && lW > 0) {
        let rx_norm = (rC.x - R_L.x) / rW;
        let lx_norm = (lC.x - L_L.x) / lW;
        irisX_norm = (rx_norm + lx_norm) / 2;
    } else {
        irisX_norm = 0.5;
    }

    const R_T = landmarks[159], R_B = landmarks[145];
    const L_T = landmarks[386], L_B = landmarks[374];
    const rH = Math.abs(R_B.y - R_T.y), lH = Math.abs(L_B.y - L_T.y);

    if (rH > 0 && lH > 0) {
        let ry_norm = (rC.y - R_T.y) / rH;
        let ly_norm = (lC.y - L_T.y) / lH;
        irisY_norm = (ry_norm + ly_norm) / 2;
    } else {
        irisY_norm = 0.5;
    }
    
    // Aplicar la calibraciÃ³n manual
    irisX_norm = (irisX_norm - CFG.calib_center.x) * CFG.scale.x + CFG.offset.x;
    if (CFG.invertY) irisY_norm = 1 - irisY_norm;
    irisY_norm = (irisY_norm - CFG.calib_center.y) * CFG.scale.y + CFG.offset.y;

    irisN.x = irisX_norm;
    irisN.y = irisY_norm;
  }

  // --- DetecciÃ³n de Rostros y Bucle Principal ---
  const faceMesh = new FaceMesh({ locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${f}` });
  faceMesh.setOptions({ maxNumFaces: 1, refineLandmarks: true, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
  faceMesh.onResults(results => {
    if (!results.multiFaceLandmarks || results.multiFaceLandmarks.length === 0) {
      cursor.style.display = 'none';
      return;
    }
    const lm = results.multiFaceLandmarks[0];
    processMouth(lm);
    processGaze(lm);

    let px = irisN.x * W;
    let py = irisN.y * H;

    const x = Math.max(0, Math.min(W, px));
    const y = Math.max(0, Math.min(H, py));

    if (mode === 'brush' || mode.startsWith('calibrating')) {
      cursor.style.display = 'block';
      cursor.style.left = x + 'px';
      cursor.style.top = y + 'px';
      if (mode === 'brush' && isPainting) {
        if (lastPoint) {
          ctx.strokeStyle = 'rgba(0,200,255,.95)'; ctx.lineWidth = CFG.brush; ctx.lineJoin = 'round'; ctx.lineCap = 'round';
          ctx.beginPath();
          ctx.moveTo(lastPoint.x, lastPoint.y);
          ctx.lineTo(x, y);
          ctx.stroke();
          drawingPoints.push({ x: x, y: y, mar: marEma, t: Date.now() });
          countEl.textContent = `pts: ${drawingPoints.length}`;
        }
        lastPoint = { x, y };
      } else {
        lastPoint = { x, y };
      }
    } else {
      cursor.style.display = 'none';
      lastPoint = null;
    }
  });

  async function startCamera() {
    if (rawVideo.srcObject) return;
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ video: { width: { ideal:1280 }, height: { ideal:720 }, facingMode:"user" } });
      rawVideo.srcObject = stream;
      await rawVideo.play();
      hideErr();
      requestAnimationFrame(faceLoop);
      showInfo('CÃ¡mara lista. Por favor, calibra tu mirada.');
    } catch (e) {
      showErr(`No se pudo acceder a la cÃ¡mara. ${e.name}: ${e.message}`);
    }
  }

  async function faceLoop() {
    if (rawVideo.readyState >= 2 && !rawVideo.paused && !rawVideo.ended) {
      await faceMesh.send({ image: rawVideo });
    }
    requestAnimationFrame(faceLoop);
  }

  // --- Funciones de CalibraciÃ³n ---
  function showCalibUI(title, description) {
    calibUI.style.display = 'flex';
    calibTitle.textContent = title;
    calibDescription.textContent = description;
  }

  function hideCalibUI() {
    calibUI.style.display = 'none';
  }

  async function startCalibProcess() {
    if (irisN.x === null) {
      showErr('AÃºn no se ha detectado tu rostro. AsegÃºrate de que la cÃ¡mara estÃ© encendida.');
      return;
    }

    mode = 'calibrating_center';
    showCalibUI("Paso 1: Centrar Mirada", "Mira al centro de la pantalla y haz clic en cualquier parte para registrar el punto central de tus ojos.");
    
    await new Promise(res => {
        stageEl.onclick = () => {
            calibrationPoints.center = {x: irisN.x, y: irisN.y};
            res();
        };
    });
    
    hideCalibUI();
    showInfo("âœ… Punto central registrado. Ahora definiremos los lÃ­mites.");
    await new Promise(r => setTimeout(r, 1000));

    // Paso 2: CalibraciÃ³n de lÃ­mites
    const limitPoints = [
      { id: 'left', title: 'Mira a la IZQUIERDA', desc: 'Mira el borde izquierdo de la pantalla y haz clic.' },
      { id: 'right', title: 'Mira a la DERECHA', desc: 'Mira el borde derecho de la pantalla y haz clic.' },
      { id: 'up', title: 'Mira ARRIBA', desc: 'Mira el borde superior de la pantalla y haz clic.' },
      { id: 'down', title: 'Mira ABAJO', desc: 'Mira el borde inferior de la pantalla y haz clic.' },
    ];

    for (const point of limitPoints) {
        showCalibUI(`Paso 2: ${point.title}`, point.desc);
        await new Promise(res => {
            stageEl.onclick = () => {
                calibrationPoints[point.id] = {x: irisN.x, y: irisN.y};
                res();
            };
        });
        hideCalibUI();
        showInfo(`âœ… Punto ${point.id} registrado.`);
        await new Promise(r => setTimeout(r, 500));
    }

    calculateCalibrationParameters();
    showInfo("âœ… CalibraciÃ³n completa. Puedes iniciar la brocha.");
  }

  function calculateCalibrationParameters() {
    const { center, left, right, up, down } = calibrationPoints;
    if (!center || !left || !right || !up || !down) return;

    // Calcular el desplazamiento (offset)
    CFG.offset.x = 0.5 - center.x;
    CFG.offset.y = 0.5 - center.y;

    // Calcular la escala (ganancia)
    const rangeX = Math.abs(right.x - left.x);
    const rangeY = Math.abs(down.y - up.y);
    
    if (rangeX > 0) CFG.scale.x = 1 / rangeX;
    if (rangeY > 0) CFG.scale.y = 1 / rangeY;
  }

  // --- Eventos de Botones ---
  document.getElementById('testCam').onclick = startCamera;
  document.getElementById('btnCalibrate').onclick = startCalibProcess;
  document.getElementById('btnStart').onclick = () => {
    mode = 'brush';
    modeTag.textContent = 'Modo: Brocha';
    showInfo('Â¡Mueve tus ojos para dibujar! Abre la boca para activar la brocha.');
  };
  document.getElementById('btnClear').onclick = () => {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawingPoints = [];
    countEl.textContent = 'pts: 0';
  };

})();
</script>
</body>
</html>
