<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Brocha: Ojos o Nariz + Boca (getUserMedia)</title>

<!-- OJOS -->
<script src="https://webgazer.cs.brown.edu/webgazer.js"></script>
<!-- CARA (boca+nariz) -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh"></script>

<style>
  html,body{margin:0;padding:0;height:100%;overflow:hidden;background:#0f1115;color:#fff}
  #wrap{position:relative;width:100%;height:100vh}
  #topbar{position:absolute;top:10px;left:10px;right:10px;display:flex;gap:8px;flex-wrap:wrap;
          background:rgba(0,0,0,.45);padding:8px 10px;border-radius:10px;align-items:center;z-index:10000}
  .btn{appearance:none;border:0;padding:6px 10px;border-radius:10px;cursor:pointer;background:#22272e;color:#fff;font-weight:600}
  .btn.primary{background:#00e676;color:#111}
  .btn.warn{background:#ff5252}
  .sp{margin-left:auto;font:12px/1.2 monospace;opacity:.9}
  #stage{position:absolute;inset:62px 10px 10px 10px;border-radius:10px;background:#10131a;overflow:hidden}
  #canvas{position:absolute;inset:0;width:100%;height:100%}
  #cursor{position:absolute;width:20px;height:20px;border:2px solid rgba(255,255,255,.95);border-radius:50%;
          pointer-events:none;transform:translate(-50%,-50%);display:none}
  #status{position:absolute;bottom:10px;left:10px;right:10px;display:flex;gap:10px;align-items:center;
          background:rgba(255,255,255,.06);padding:8px 10px;border-radius:10px;z-index:9999}
  #modeTag{font-weight:700;background:#1f2937;padding:4px 8px;border-radius:8px}
  #marPanel{display:flex;align-items:center;gap:8px;flex:1}
  #marBar{position:relative;height:10px;flex:1;background:#2b2f3a;border-radius:6px;overflow:hidden}
  #marFill{position:absolute;top:0;left:0;height:100%;width:0%;background:#00e676}
  #marThr{position:absolute;top:-3px;width:2px;height:16px;background:#ff5252;left:50%}
  #marVal{min-width:92px;text-align:right;font:12px/1 monospace;opacity:.9}
  #preview{position:absolute;top:10px;right:10px;width:300px;height:225px;background:#000a;border-radius:8px;display:none;z-index:5000}
  video#rawVideo{display:none}
  #errbar{position:absolute;bottom:0;left:0;right:0;background:#ff3344;color:#100;padding:6px 10px;font:12px/1.3 monospace;
          display:none;z-index:10001}

  /* --- ROI overlay & targets --- */
  .roi-overlay{position:absolute;inset:0;pointer-events:none}
  .roi-rect{position:absolute;border:2px dashed rgba(0,230,118,.9);border-radius:8px;box-shadow:0 0 0 200vmax rgba(0,0,0,.45) inset}
  .calib-target{position:absolute;width:18px;height:18px;border-radius:50%;background:#00e676;
                box-shadow:0 0 0 6px rgba(0,230,118,.2);transform:translate(-50%,-50%);pointer-events:auto;cursor:crosshair}
  .calib-target.wait{background:#fbbf24; box-shadow:0 0 0 6px rgba(251,191,36,.25)}
  .calib-target.done{background:#22d3ee; box-shadow:0 0 0 6px rgba(34,211,238,.25)}
</style>
</head>
<body>
<div id="wrap">
  <div id="topbar">
    <button id="testCam" class="btn">üé• Probar c√°mara</button>
    <button id="modeFace" class="btn">1) Test de Boca</button>
    <button id="modeGaze" class="btn">2) Test de Movimiento</button>
    <button id="modeBrush" class="btn primary">3) Iniciar Brocha</button>

    <button id="btnRoi" class="btn">üñ±Ô∏è Definir zona de mirada (ROI)</button>
    <button id="btnCalRoi" class="btn">üéØ Calibraci√≥n guiada (ROI)</button>
    <button id="btnResetCal" class="btn warn">‚ôªÔ∏è Reset Calibraci√≥n</button>

    <button id="togglePreview" class="btn">üëÅÔ∏è Preview</button>
    <button id="clear" class="btn warn">üßπ Limpiar</button>
    <button id="savePng" class="btn">üñºÔ∏è PNG</button>
    <button id="saveCsv" class="btn">üìÑ CSV</button>
    <span class="sp" id="count">pts: 0</span>
  </div>

  <div id="stage">
    <canvas id="canvas"></canvas>
    <div id="cursor"></div>
    <canvas id="preview"></canvas>
    <video id="rawVideo" playsinline autoplay muted></video>
    <div class="roi-overlay" id="roiOverlay"></div>
  </div>

  <div id="status">
    <span id="modeTag">Modo: Test de Boca</span>
    <div id="marPanel">
      <span>MAR:</span>
      <div id="marBar"><div id="marFill"></div><div id="marThr"></div></div>
      <span id="marVal">‚Äî</span>
    </div>
  </div>

  <div id="errbar"></div>
</div>

<script>
(function(){
  // -------- errores visibles --------
  const errbar=document.getElementById('errbar');
  function showErr(msg){ errbar.textContent='‚ö†Ô∏è '+msg; errbar.style.display='block'; }
  window.onerror=(m,src,l,c)=>showErr((m||'Error')+(l?` @${l}:${c||0}`:''));
  window.onunhandledrejection=(ev)=>showErr('Promise rejection: '+(ev.reason?.message||ev.reason||''));

  // -------- config desde Python --------
  const CFG = Object.assign({brush:8, alpha:.45, mouthThr:.28, debug:true, controlMode:'eyes'}, window.DIAG_CFG||{});

  // -------- DOM --------
  const stageEl=document.getElementById('stage');
  const canvas=document.getElementById('canvas'); const ctx=canvas.getContext('2d');
  const cursor=document.getElementById('cursor');
  const preview=document.getElementById('preview'); const pctx=preview.getContext('2d');
  const rawVideo=document.getElementById('rawVideo');
  const countEl=document.getElementById('count'); const modeTag=document.getElementById('modeTag');
  const marVal=document.getElementById('marVal'); const marFill=document.getElementById('marFill'); const marThr=document.getElementById('marThr');
  const roiOverlay=document.getElementById('roiOverlay');

  // -------- estado --------
  let mode='face'; // 'face' | 'gmove' | 'brush'
  let brush=CFG.brush, alpha=CFG.alpha, mouthThr=CFG.mouthThr;
  let dpr=1, W=0, H=0, pts=[], last=null, smoothed=null;
  let marDbg=0;

  // movimiento: ojos
  let gaze={x:null,y:null};
  // movimiento: nariz
  let nose={x:null,y:null,z:null};
  let faceBox=null; // bbox para normalizar nariz -> pantalla

  // Calibraci√≥n af√≠n (solo modo ojos)
  let A=[1,0,0,1], b=[0,0];
  const LS_KEY='diag_calib_affine_v1';
  const ROI_KEY='diag_roi_norm_v1';

  // ROI normalizado (0..1 sobre stage)
  let roiNorm = loadJson(ROI_KEY) || {x0:0.05,y0:0.08,x1:0.95,y1:0.92};

  // -------- tama√±o --------
  function resize(){
    dpr=Math.min(window.devicePixelRatio||1,2);
    const r=stageEl.getBoundingClientRect();
    canvas.width=Math.floor(r.width*dpr); canvas.height=Math.floor(r.height*dpr);
    canvas.style.width=r.width+'px'; canvas.style.height=r.height+'px'; ctx.setTransform(dpr,0,0,dpr,0,0);
    preview.width=Math.floor(300*dpr); preview.height=Math.floor(225*dpr);
    preview.style.width='300px'; preview.style.height='225px'; pctx.setTransform(dpr,0,0,dpr,0,0);
    W=r.width; H=r.height;
    drawRoiRect(); // redibujar ROI
  }
  window.addEventListener('resize', resize); resize();

  // -------- UI --------
  document.getElementById('modeFace').onclick=()=>setMode('face');
  document.getElementById('modeGaze').onclick=()=>setMode('gmove');
  document.getElementById('modeBrush').onclick=()=>setMode('brush');
  document.getElementById('togglePreview').onclick=()=>{preview.style.display=(preview.style.display==='none'||preview.style.display==='')?'block':'none';};
  document.getElementById('clear').onclick=()=>{ctx.clearRect(0,0,canvas.width,canvas.height); pts=[]; countEl.textContent='pts: 0'; last=null; smoothed=null;};
  document.getElementById('savePng').onclick=()=>{const a=document.createElement('a'); a.download=`brocha_${Date.now()}.png`; a.href=canvas.toDataURL('image/png'); a.click();};
  document.getElementById('saveCsv').onclick=()=>{const header='t_ms,x,y,mar,mode\n'; const body=pts.map(p=>`${p.t},${Math.round(p.x)},${Math.round(p.y)},${(p.mar??0).toFixed(4)},${CFG.controlMode}`).join('\n'); const blob=new Blob([header+body],{type:'text/csv'}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download=`brocha_${CFG.controlMode}_${Date.now()}.csv`; a.click(); URL.revokeObjectURL(url);};

  // ROI & Calibraci√≥n avanzada
  document.getElementById('btnRoi').onclick = defineRoiWithMouse;
  document.getElementById('btnCalRoi').onclick = guidedRoiCalibration;
  document.getElementById('btnResetCal').onclick = ()=>{ A=[1,0,0,1]; b=[0,0]; saveJson(LS_KEY,{A,b}); alert('Calibraci√≥n reiniciada.'); };

  function setMode(m){
    mode=m;
    modeTag.textContent='Modo: '+(m==='face'?'Test de Boca': m==='gmove'?'Test de Movimiento':'Brocha');
    if(m==='face') cursor.style.display='none';
  }

  // -------- c√°mara --------
  let gStream=null;
  document.getElementById('testCam').onclick=async ()=>{
    try{
      gStream=await navigator.mediaDevices.getUserMedia({video:{width:640,height:480}});
      rawVideo.srcObject=gStream; await rawVideo.play(); errbar.style.display='none';
      alert('‚úÖ C√°mara iniciada.');
    }catch(e){ showErr('getUserMedia: '+(e.name||'')+' ‚Äî '+(e.message||'')); }
  };

  // -------- FaceMesh (boca + nariz) --------
  const faceMesh=new FaceMesh({ locateFile:(f)=>`https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${f}` });
  faceMesh.setOptions({maxNumFaces:3, refineLandmarks:true, minDetectionConfidence:.5, minTrackingConfidence:.5});

  function bboxOf(lm){let minx=1,miny=1,maxx=0,maxy=0; for(const p of lm){minx=Math.min(minx,p.x); miny=Math.min(miny,p.y); maxx=Math.max(maxx,p.x); maxy=Math.max(maxy,p.y);} return {minx,miny,maxx,maxy,cx:(minx+maxx)/2,cy:(miny+maxy)/2,area:(maxx-minx)*(maxy-miny)};}
  function pickMainFace(arr){ if(!arr||!arr.length) return null; let k=0,b=Infinity; for(let i=0;i<arr.length;i++){ const bb=bboxOf(arr[i]); const dc=(bb.cx-0.5)**2+(bb.cy-0.5)**2; const s=dc/(bb.area+1e-6); if(s<b){b=s;k=i;} } return arr[k]; }
  function dist(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }

  async function faceLoop(){ try{ if(rawVideo.readyState>=2 && !rawVideo.paused && !rawVideo.ended){ await faceMesh.send({image:rawVideo}); } }catch(e){ showErr('faceLoop: '+e.message); } requestAnimationFrame(faceLoop); }

  faceMesh.onResults(res=>{
    if(!res.multiFaceLandmarks || !res.multiFaceLandmarks.length) return;
    const main = pickMainFace(res.multiFaceLandmarks); if(!main) return;

    // --- boca (MAR) ---
    const top=main[13], bottom=main[14], left=main[78], right=main[308];
    const mar = dist(top,bottom)/Math.max(1e-6, dist(left,right)); marDbg=mar;
    marVal.textContent = mar.toFixed(3);
    marFill.style.width = (Math.max(0, Math.min(1, mar/0.8))*100).toFixed(0)+'%';
    marThr.style.left   = (Math.max(0, Math.min(1, mouthThr/0.8))*100).toFixed(0)+'%';

    // --- nariz (posici√≥n) ---
    const NOSE_IDX=[1,4];
    let nz = main[NOSE_IDX[0]];
    for(const idx of NOSE_IDX){ if(main[idx] && main[idx].z < nz.z) nz = main[idx]; }
    nose = {x:nz.x, y:nz.y, z:nz.z};
    faceBox = bboxOf(main); // para normalizar XY

    // preview
    if(preview.style.display!=='none'){
      pctx.clearRect(0,0,preview.width,preview.height);
      pctx.drawImage(rawVideo,0,0,preview.width,preview.height);
      pctx.fillStyle='#0f0';
      const nx = nose.x*preview.width, ny = nose.y*preview.height;
      pctx.beginPath(); pctx.arc(nx,ny,4,0,Math.PI*2); pctx.fill();
      pctx.fillStyle='#fff'; pctx.fillText(`MAR=${mar.toFixed(3)}`,8,16);
    }
  });

  // -------- WebGazer (ojos) --------
  try{
    webgazer.setRegression('ridge'); webgazer.setTracker('TFFacemesh');
    if(webgazer.params){
      webgazer.params.showVideoPreview=false;
      webgazer.params.showFaceFeedbackBox=false;
      webgazer.params.showPredictionPoints=false;
    }
    webgazer.begin();
    webgazer.setGazeListener((data)=>{ if(!data) return; gaze.x=data.x; gaze.y=data.y; });
  }catch(e){ showErr('webgazer init: '+e.message); }

  // -------- Cargar calibraci√≥n previa --------
  const saved = loadJson(LS_KEY);
  if(saved && saved.A && saved.b){ A=saved.A; b=saved.b; }

  // -------- bucle principal: mover + pintar --------
  function loop(){
    // 1) Coordenadas de control ‚Üí (x,y) del canvas
    let cx=null, cy=null;

    if(CFG.controlMode==='eyes' && gaze.x!=null && gaze.y!=null){
      const r=stageEl.getBoundingClientRect();
      // ventana -> stage
      const gx = gaze.x - r.left, gy = gaze.y - r.top;
      // suavizado
      if(!smoothed) smoothed={x:gx,y:gy};
      smoothed.x = alpha*gx + (1-alpha)*smoothed.x;
      smoothed.y = alpha*gy + (1-alpha)*smoothed.y;
      // af√≠n
      cx = A[0]*smoothed.x + A[1]*smoothed.y + b[0];
      cy = A[2]*smoothed.x + A[3]*smoothed.y + b[1];
    }

    if(CFG.controlMode==='nose' && nose.x!=null && faceBox){
      // normaliza nariz dentro de la caja de la cara ‚Üí [0..1]
      const nx = (nose.x - faceBox.minx)/Math.max(1e-6, (faceBox.maxx - faceBox.minx));
      const ny = (nose.y - faceBox.miny)/Math.max(1e-6, (faceBox.maxy - faceBox.miny));
      const tx = nx * W, ty = ny * H;
      // suavizado
      if(!smoothed) smoothed={x:tx,y:ty};
      smoothed.x = alpha*tx + (1-alpha)*smoothed.x;
      smoothed.y = alpha*ty + (1-alpha)*smoothed.y;
      cx = smoothed.x; cy = smoothed.y;
    }

    // 2) Mostrar cursor y pintar si boca abierta
    if(cx!=null && cy!=null){
      const x = Math.max(0, Math.min(W-1, cx));
      const y = Math.max(0, Math.min(H-1, cy));

      if(mode!=='face'){
        cursor.style.display='block';
        cursor.style.left=x+'px'; cursor.style.top=y+'px';
        cursor.style.width=(brush*2)+'px'; cursor.style.height=(brush*2)+'px';
      } else { cursor.style.display='none'; }

      const mouthOpen = marDbg > mouthThr;
      if(mode==='brush' && mouthOpen){
        if(last){
          ctx.strokeStyle='rgba(0,200,255,.95)'; ctx.lineWidth=brush; ctx.lineJoin='round'; ctx.lineCap='round';
          ctx.beginPath(); ctx.moveTo(last.x,last.y); ctx.lineTo(x,y); ctx.stroke();
          pts.push({t:Date.now(), x, y, mar:marDbg});
          countEl.textContent = `pts: ${pts.length}`;
        }
      }
      last={x,y};
    }

    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);
  requestAnimationFrame(faceLoop);

  // ================================
  //   Calibraci√≥n ROI Avanzada
  // ================================
  function defineRoiWithMouse(){
    alert('Arrastra con el mouse para dibujar la zona (ROI) donde mirar√°s con los ojos.');
    const r=stageEl.getBoundingClientRect();
    let start=null, rectEl=null;

    function onDown(e){
      start={x:e.clientX - r.left, y:e.clientY - r.top};
      if(!rectEl){
        rectEl=document.createElement('div');
        rectEl.className='roi-rect';
        roiOverlay.appendChild(rectEl);
      }
      placeRect(start.x,start.y,1,1);
      window.addEventListener('mousemove',onMove);
      window.addEventListener('mouseup',onUp,{once:true});
    }
    function onMove(e){
      const x=e.clientX - r.left, y=e.clientY - r.top;
      const x0=Math.min(start.x,x), y0=Math.min(start.y,y);
      const x1=Math.max(start.x,x), y1=Math.max(start.y,y);
      placeRect(x0,y0, x1-x0, y1-y0);
    }
    function onUp(e){
      window.removeEventListener('mousemove',onMove);
      const bb=rectEl.getBoundingClientRect();
      // Normalizar a [0..1] relativo al stage
      const x0=(bb.left - r.left)/r.width, y0=(bb.top - r.top)/r.height;
      const x1=(bb.right - r.left)/r.width, y1=(bb.bottom - r.top)/r.height;
      roiNorm = {x0:clamp01(x0), y0:clamp01(y0), x1:clamp01(x1), y1:clamp01(y1)};
      saveJson(ROI_KEY, roiNorm);
      alert('ROI guardada. Ahora puedes ejecutar la Calibraci√≥n guiada.');
    }
    stageEl.addEventListener('mousedown',onDown,{once:true});

    function placeRect(x,y,w,h){
      rectEl.style.left=x+'px';
      rectEl.style.top=y+'px';
      rectEl.style.width=w+'px';
      rectEl.style.height=h+'px';
    }
  }

  function drawRoiRect(){
    roiOverlay.innerHTML='';
    const r=stageEl.getBoundingClientRect();
    const x0=roiNorm.x0*r.width, y0=roiNorm.y0*r.height;
    const w =(roiNorm.x1-roiNorm.x0)*r.width;
    const h =(roiNorm.y1-roiNorm.y0)*r.height;
    const rectEl=document.createElement('div');
    rectEl.className='roi-rect';
    rectEl.style.left=x0+'px'; rectEl.style.top=y0+'px';
    rectEl.style.width=w+'px'; rectEl.style.height=h+'px';
    roiOverlay.appendChild(rectEl);
  }

  async function guidedRoiCalibration(){
    if(CFG.controlMode!=='eyes'){
      alert('La calibraci√≥n guiada aplica al control por OJOS. Cambia ‚ÄúMover brocha con‚Äù a OJOS y vuelve a intentar.');
      return;
    }
    const r=stageEl.getBoundingClientRect();
    const rx0=roiNorm.x0*r.width, ry0=roiNorm.y0*r.height;
    const rw =(roiNorm.x1-roiNorm.x0)*r.width;
    const rh =(roiNorm.y1-roiNorm.y0)*r.height;

    // Definimos 9 objetivos: 4 esquinas, centro, 4 puntos medios
    const nx=[0,0.5,1], ny=[0,0.5,1];
    const targets=[];
    for(const ix of nx) for(const iy of ny){
      targets.push({ x: rx0 + ix*rw, y: ry0 + iy*rh });
    }

    roiOverlay.innerHTML='';
    drawRoiRect();
    // Crear elementos clicables
    const els=[];
    for(const t of targets){
      const el=document.createElement('div');
      el.className='calib-target wait';
      el.style.left=t.x+'px'; el.style.top=t.y+'px';
      roiOverlay.appendChild(el);
      els.push(el);
    }

    alert('Calibraci√≥n: haz clic en cada punto y MIRA ese punto. Tras el clic, mant√©n tu mirada fija ~1.2s hasta que cambie de color.');

    const gazePts=[], tgtPts=[];
    for(let i=0;i<targets.length;i++){
      const el=els[i]; const t=targets[i];
      await new Promise(res=>{
        const onceClick = async (ev)=>{
          el.classList.remove('wait'); el.classList.add('calib-target');
          // Recolectar muestras de gaze 1200 ms
          const samples=[];
          const t0=performance.now();
          function step(){
            const now=performance.now();
            if(gaze.x!=null&&gaze.y!=null){
              // stage coords nativos
              samples.push([gaze.x - r.left, gaze.y - r.top]);
            }
            if(now-t0<1200){ requestAnimationFrame(step); }
            else{
              const m=mean2(samples);
              if(!isNaN(m[0])){ gazePts.push(m); tgtPts.push([t.x, t.y]); }
              el.classList.add('done');
              res();
            }
          }
          requestAnimationFrame(step);
        };
        el.addEventListener('click', onceClick, {once:true});
      });
      await sleep(150);
    }

    const sol=lsqAffine(gazePts, tgtPts);
    if(sol){
      A=sol.A; b=sol.b;
      saveJson(LS_KEY, {A,b});
      alert('‚úÖ Calibraci√≥n af√≠n completada y guardada.');
    }else{
      alert('No se pudo calibrar (muestras insuficientes o degeneradas).');
    }
  }

  // -------- utils --------
  function sleep(ms){return new Promise(r=>setTimeout(r,ms));}
  function mean2(a){if(!a.length)return[NaN,NaN];const sx=a.reduce((s,v)=>s+v[0],0), sy=a.reduce((s,v)=>s+v[1],0);return[sx/a.length, sy/a.length];}
  function clamp01(v){return Math.max(0,Math.min(1,v));}
  function transpose(A){const m=A.length,n=A[0].length,AT=Array.from({length:n},()=>Array(m).fill(0));for(let i=0;i<m;i++)for(let j=0;j<n;j++)AT[j][i]=A[i][j];return AT;}
  function mul(A,B){const m=A.length,n=A[0].length,p=B[0].length,C=Array.from({length:m},()=>Array(p).fill(0));for(let i=0;i<m;i++)for(let k=0;k<n;k++)for(let j=0;j<p;j++)C[i][j]+=A[i][k]*B[k][j];return C;}
  function mulVec(A,v){const m=A.length,n=A[0].length,r=Array(m).fill(0);for(let i=0;i<m;i++)for(let j=0;j<n;j++)r[i]+=A[i][j]*v[j];return r;}
  function solveGaussian(A,b){const n=A.length,M=A.map((row,i)=>row.concat([b[i]]));for(let i=0;i<n;i++){let max=i;for(let r=i+1;r<n;r++)if(Math.abs(M[r][i])>Math.abs(M[max][i]))max=r;if(Math.abs(M[max][i])<1e-9)return null;[M[i],M[max]]=[M[max],M[i]];const piv=M[i][i];for(let k=i;k<=n;k++)M[i][k]/=piv;for(let r=0;r<n;r++)if(r!==i){const f=M[r][i];for(let k=i;k<=n;k++)M[r][k]-=f*M[i][k];}}return M.map(row=>row[n]);}
  function lsqAffine(gPts,tPts){
    if(!gPts.length || gPts.length<3) return null; // af√≠n 6 params ‚Üí ‚â•3 pares
    const M=[],Z=[];
    for(let i=0;i<gPts.length;i++){
      const[gx,gy]=gPts[i]; const[tx,ty]=tPts[i];
      M.push([gx,gy,0,0,1,0]); Z.push(tx);
      M.push([0,0,gx,gy,0,1]); Z.push(ty);
    }
    const Mt=transpose(M),MtM=mul(Mt,M),MtZ=mulVec(Mt,Z),p=solveGaussian(MtM,MtZ);
    return p?{A:[p[0],p[1],p[2],p[3]],b:[p[4],p[5]]}:null;
  }
  function saveJson(k,v){ try{ localStorage.setItem(k, JSON.stringify(v)); }catch(e){} }
  function loadJson(k){ try{ const s=localStorage.getItem(k); return s?JSON.parse(s):null; }catch(e){ return null; } }

})();
</script>
</body>
</html>
