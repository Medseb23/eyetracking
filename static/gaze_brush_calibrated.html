<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Gaze Brush Mouth</title>

<!-- WebGazer para mirada -->
<script src="https://webgazer.cs.brown.edu/webgazer.js"></script>

<!-- MediaPipe FaceMesh (detecci√≥n boca) -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>

<style>
  html, body { margin:0; padding:0; height:100%; overflow:hidden; background:#111; }
  #wrap { position:relative; width:100%; height:100vh; }
  #canvas { position:absolute; inset:0; width:100%; height:100%; background:#111; }
  #cursor { position:absolute; width:16px; height:16px; border-radius:50%; pointer-events:none;
            border:2px solid rgba(255,255,255,.85); transform:translate(-50%,-50%); }
  #hud { position:absolute; top:10px; left:10px; right:10px; display:flex; gap:8px; flex-wrap:wrap;
         background:rgba(0,0,0,.55); color:#fff; padding:8px 10px; border-radius:10px;
         font:12px/1.3 ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial; }
  .btn { appearance:none; border:0; padding:6px 10px; border-radius:10px; cursor:pointer;
         background:#222; color:#fff; font-weight:600; }
  .btn.primary { background:#00e676; color:#111; }
  .btn.warn { background:#ff5252; }
  #stat { margin-left:auto; font-family:monospace; }
  #dbg { position:absolute; bottom:10px; left:10px; color:#fff; font:12px monospace; }
  #webgazerVideoContainer { display:none !important; } /* oculta preview de WebGazer */
  video#inputVideo { display:none; } /* video de MediaPipe oculto */
  canvas#landmarks { position:absolute; top:10px; right:10px; width:260px; height:200px;
                     background:#0008; display:none; }
</style>
</head>
<body>
<div id="wrap">
  <canvas id="canvas"></canvas>
  <div id="cursor"></div>

  <div id="hud">
    <button id="start" class="btn primary">‚ñ∂Ô∏è Iniciar</button>
    <button id="stop" class="btn">‚è∏Ô∏è Pausar</button>
    <button id="clear" class="btn warn">üßπ Limpiar</button>
    <button id="savePng" class="btn">üñºÔ∏è PNG</button>
    <button id="saveCsv" class="btn">üìÑ CSV</button>
    <span id="stat">‚Äî</span>
  </div>

  <div id="dbg">mirada: x=‚Äì y=‚Äì | MAR=‚Äì | umbral=‚Äì | dibujando: no</div>
  <video id="inputVideo" playsinline></video>
  <canvas id="landmarks"></canvas>
</div>

<script>
(async function(){
  // Config inyectada desde Streamlit
  const cfg = window.GAZE_BRUSH_CONFIG || {brush: 6, alpha: .4, mouthThr: .28, debug: false};

  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const cursor = document.getElementById('cursor');
  const stat = document.getElementById('stat');
  const dbg = document.getElementById('dbg');
  const inputVideo = document.getElementById('inputVideo');
  const lmCanvas = document.getElementById('landmarks');
  const lmCtx = lmCanvas.getContext('2d');
  lmCanvas.style.display = cfg.debug ? 'block' : 'none';

  const startBtn = document.getElementById('start');
  const stopBtn  = document.getElementById('stop');
  const clearBtn = document.getElementById('clear');
  const savePng  = document.getElementById('savePng');
  const saveCsv  = document.getElementById('saveCsv');

  let W=0,H=0,dpr=1;
  let running=false;
  let alpha = cfg.alpha;
  let brush = cfg.brush;
  let mouthThr = cfg.mouthThr;   // umbral MAR (puedes cambiarlo desde la UI de Streamlit)
  let smoothed = null;
  let last = null;
  let drawing = false; // se activa cuando MAR > umbral
  const pts = [];      // {t,x,y,mar,drawing}

  function resize(){
    dpr = Math.min(window.devicePixelRatio || 1, 2);
    W = canvas.clientWidth;
    H = canvas.clientHeight;
    canvas.width = Math.floor(W * dpr);
    canvas.height= Math.floor(H * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  window.addEventListener('resize', resize);
  resize();

  // ====== WebGazer: Mirada ======
  window.saveDataAcrossSessions = true;
  webgazer.setRegression('ridge')
          .setTracker('TFFacemesh')
          .begin()
          .showVideoPreview(false)
          .showPredictionPoints(false)
          .showFaceFeedbackBox(false);

  let gaze = {x:null,y:null};
  webgazer.setGazeListener((data)=>{
    if(!data) return;
    gaze.x = data.x; gaze.y = data.y;
  });

  // ====== MediaPipe FaceMesh: MAR (Mouth Aspect Ratio) ======
  const faceMesh = new FaceMesh.FaceMesh({
    locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`
  });
  faceMesh.setOptions({
    maxNumFaces: 1,
    refineLandmarks: true,
    minDetectionConfidence: 0.5,
    minTrackingConfidence: 0.5
  });

  function dist(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }

  let mar = 0;
  faceMesh.onResults(results => {
    if(!results.multiFaceLandmarks || results.multiFaceLandmarks.length===0) return;
    const lm = results.multiFaceLandmarks[0];
    // Landmarks de labios (aprox indices MediaPipe)
    const top = lm[13];     // labio superior interno
    const bottom = lm[14];  // labio inferior interno
    const left = lm[78];    // extremo izquierdo boca
    const right = lm[308];  // extremo derecho boca
    mar = dist(top,bottom) / Math.max(1e-6, dist(left,right));
    drawing = mar > mouthThr;

    if(cfg.debug){
      lmCtx.clearRect(0,0,lmCanvas.width,lmCanvas.height);
      lmCtx.fillStyle = "#0f0"; lmCtx.strokeStyle="#0f0"; lmCtx.lineWidth=1;
      const w = lmCanvas.width, h = lmCanvas.height;
      function P(p){ return [p.x*w, p.y*h]; }
      const ptsD = [top,bottom,left,right].map(P);
      for(const p of ptsD){ lmCtx.beginPath(); lmCtx.arc(p[0],p[1],3,0,Math.PI*2); lmCtx.fill(); }
      lmCtx.beginPath(); lmCtx.moveTo(...ptsD[0]); lmCtx.lineTo(...ptsD[1]); lmCtx.stroke();
      lmCtx.beginPath(); lmCtx.moveTo(...ptsD[2]); lmCtx.lineTo(...ptsD[3]); lmCtx.stroke();
      lmCtx.fillStyle = "#fff";
      lmCtx.fillText(`MAR=${mar.toFixed(3)} thr=${mouthThr.toFixed(2)}`, 8, 16);
    }
  });

  // C√°mara para FaceMesh (baja resoluci√≥n para ahorrar CPU)
  let frameCount = 0;
  const camera = new Camera.Camera(inputVideo, {
    onFrame: async () => {
      // Procesa ~cada 3 frames (~10‚Äì15 fps)
      frameCount = (frameCount + 1) || 1;
      if (frameCount % 3 === 0) await faceMesh.send({image: inputVideo});
    },
    width: 320, height: 240
  });
  camera.start();

  // ====== Bucle de dibujo ======
  function step(){
    if(running && gaze.x!=null && gaze.y!=null){
      if(!smoothed) smoothed = {x:gaze.x, y:gaze.y};
      smoothed.x = alpha * gaze.x + (1-alpha) * smoothed.x;
      smoothed.y = alpha * gaze.y + (1-alpha) * smoothed.y;

      const x = Math.max(0, Math.min(W-1, smoothed.x));
      const y = Math.max(0, Math.min(H-1, smoothed.y));

      // cursor (tama√±o = 2*brush)
      cursor.style.left = x + 'px';
      cursor.style.top  = y + 'px';
      cursor.style.width = (brush*2) + 'px';
      cursor.style.height= (brush*2) + 'px';

      if(drawing && last){
        ctx.strokeStyle = 'rgba(0,200,255,0.95)';
        ctx.lineWidth = brush;
        ctx.lineJoin = 'round';
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(last.x, last.y);
        ctx.lineTo(x, y);
        ctx.stroke();
      }

      last = {x, y};
      pts.push({t: Date.now(), x, y, mar: mar || 0, drawing: drawing ? 1 : 0});
      stat.textContent = `pts: ${pts.length}`;
    }
    dbg.textContent = `mirada: x=${gaze.x?gaze.x.toFixed(0):'‚Äì'} y=${gaze.y?gaze.y.toFixed(0):'‚Äì'} | MAR=${mar?mar.toFixed(3):'‚Äì'} | umbral=${mouthThr?mouthThr.toFixed(2):'‚Äì'} | dibujando: ${drawing?'s√≠':'no'}`;
    requestAnimationFrame(step);
  }
  requestAnimationFrame(step);

  // ====== UI ======
  startBtn.addEventListener('click', ()=>{ running = true; });
  stopBtn.addEventListener('click',  ()=>{ running = false; last=null; });
  clearBtn.addEventListener('click', ()=>{
    running=false; last=null; smoothed=null; pts.length=0;
    ctx.clearRect(0,0,canvas.width,canvas.height);
  });

  // Guardar PNG
  savePng.addEventListener('click', ()=>{
    const a = document.createElement('a');
    a.download = `gaze_brush_${Date.now()}.png`;
    a.href = canvas.toDataURL('image/png');
    a.click();
  });

  // Guardar CSV
  function toCsv(rows){
    const header = 't_ms,x,y,mar,drawing\n';
    const body = rows.map(r => `${r.t},${Math.round(r.x)},${Math.round(r.y)},${r.mar.toFixed(4)},${r.drawing}`).join('\n');
    return header + body;
  }
  saveCsv.addEventListener('click', ()=>{
    const blob = new Blob([toCsv(pts)], {type:'text/csv'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `gaze_points_${Date.now()}.csv`;
    a.click();
    URL.revokeObjectURL(url);
  });

  // DPI / resize sync del canvas
  const ro = new ResizeObserver(entries=>{
    for(const e of entries){
      const r = e.contentRect;
      canvas.width  = Math.floor(r.width * dpr);
      canvas.height = Math.floor(r.height * dpr);
      ctx.setTransform(dpr,0,0,dpr,0,0);
    }
  });
  ro.observe(canvas);

  // Atajo de prueba: tecla D como ‚Äúgatillo‚Äù manual (por si la boca falla)
  window.addEventListener('keydown', e => { if(e.key==='d' || e.key==='D') drawing = true; });
  window.addEventListener('keyup',   e => { if(e.key==='d' || e.key==='D') drawing = false; });

})();
</script>
</body>
</html>
