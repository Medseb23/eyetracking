<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Gaze Brush Calibrated</title>
<!-- WebGazer -->
<script src="https://webgazer.cs.brown.edu/webgazer.js"></script>
<!-- MediaPipe FaceMesh -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
<style>
  html, body { margin:0; padding:0; height:100%; overflow:hidden; background:#101114; color:#fff; }
  #wrap { position:relative; width:100%; height:100vh; }
  #canvas { position:absolute; inset:0; width:100%; height:100%; background:#0f1115; }
  #cursor { position:absolute; width:20px; height:20px; border-radius:50%; pointer-events:none;
            border:2px solid rgba(255,255,255,.9); transform:translate(-50%,-50%); }
  #hud { position:absolute; top:10px; left:10px; right:10px; display:flex; gap:8px; flex-wrap:wrap;
         background:rgba(0,0,0,.45); padding:8px 10px; border-radius:10px; align-items:center; }
  .btn { appearance:none; border:0; padding:6px 10px; border-radius:10px; cursor:pointer;
         background:#22272e; color:#fff; font-weight:600; }
  .btn.primary { background:#00e676; color:#111; }
  .btn.warn { background:#ff5252; }
  .sp { margin-left:auto; font:12px/1.2 monospace; opacity:.9; }
  #dbg { position:absolute; bottom:54px; left:10px; font:12px/1.3 monospace; opacity:.9; }
  #webgazerVideoContainer { display:none !important; }
  #landmarks { position:absolute; top:10px; right:10px; width:280px; height:210px; background:#0008; display:none; border-radius:8px; }
  #calibDot { position:fixed; width:18px; height:18px; border-radius:50%; background:#ffcc00; border:2px solid #222;
              display:none; box-shadow:0 0 0 6px rgba(255,204,0,.25); transform:translate(-50%,-50%); z-index:9999; }
  #calibMsg { position:fixed; top:50%; left:50%; transform:translate(-50%,-50%);
              background:rgba(0,0,0,.75); color:#fff; padding:10px 14px; border-radius:10px;
              font:14px/1.3 ui-sans-serif, system-ui; display:none; z-index:9999; }
  /* Panel MAR */
  #marPanel{ position:absolute; bottom:10px; left:10px; right:10px; display:flex; gap:10px; align-items:center;
             background:rgba(0,0,0,.55); color:#fff; padding:6px 10px; border-radius:10px; font:12px/1.3 ui-sans-serif, system-ui; }
  #marBar{ position:relative; height:10px; flex:1; background:#333; border-radius:6px; overflow:hidden; }
  #marFill{ position:absolute; top:0; left:0; height:100%; width:0%; background:#00e676; }
  #marThr{ position:absolute; top:-3px; width:2px; height:16px; background:#ff5252; left:50%; }
</style>
</head>
<body>
<div id="wrap">
  <canvas id="canvas"></canvas>
  <div id="cursor"></div>

  <div id="hud">
    <button id="start" class="btn primary">‚ñ∂Ô∏è Iniciar</button>
    <button id="stop" class="btn">‚è∏Ô∏è Pausar</button>
    <button id="clear" class="btn warn">üßπ Limpiar</button>
    <button id="savePng" class="btn">üñºÔ∏è PNG</button>
    <button id="saveCsv" class="btn">üìÑ CSV</button>
    <button id="calGaze" class="btn">üéØ Calibrar mirada</button>
    <button id="calMouth" class="btn">üëÑ Calibrar boca</button>
    <button id="togglePreview" class="btn">üëÅÔ∏è Preview</button>
    <span class="sp" id="stat">‚Äî</span>
  </div>

  <div id="dbg">mirada: x=‚Äì y=‚Äì | MAR=‚Äì | umbral=‚Äì | dibujando: no</div>
  <canvas id="landmarks"></canvas>
  <div id="calibDot"></div>
  <div id="calibMsg"></div>

  <div id="marPanel">
    <span>MAR:</span>
    <div id="marBar">
      <div id="marFill"></div>
      <div id="marThr"></div>
    </div>
    <span id="marVal">‚Äì</span>
  </div>
</div>

<script>
(function(){
  const cfg = window.GAZE_CFG || {brush: 8, alpha: .45, mouthThr: .28, debug: false};

  // DOM refs
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const cursor = document.getElementById('cursor');
  const stat = document.getElementById('stat');
  const dbg = document.getElementById('dbg');
  const lmCanvas = document.getElementById('landmarks');
  const lmCtx = lmCanvas.getContext('2d');
  lmCanvas.style.display = cfg.debug ? 'block' : 'none';

  const startBtn = document.getElementById('start');
  const stopBtn  = document.getElementById('stop');
  const clearBtn = document.getElementById('clear');
  const savePng  = document.getElementById('savePng');
  const saveCsv  = document.getElementById('saveCsv');
  const calGaze  = document.getElementById('calGaze');
  const calMouth = document.getElementById('calMouth');
  const togglePreview = document.getElementById('togglePreview');

  const calibDot = document.getElementById('calibDot');
  const calibMsg = document.getElementById('calibMsg');

  const marBar = document.getElementById('marBar');
  const marFill = document.getElementById('marFill');
  const marThr = document.getElementById('marThr');
  const marVal = document.getElementById('marVal');

  // State
  let W=0,H=0,dpr=1;
  let running=false, drawing=false;
  let brush = cfg.brush;
  let alpha = cfg.alpha;
  let smoothed=null, last=null;
  let points=[];
  let mouthThr = cfg.mouthThr;
  let marDbg = 0;

  // Gaze affine calibration parameters
  let A = [1,0,0,1], b = [0,0];

  function resize(){
    dpr = Math.min(window.devicePixelRatio || 1, 2);
    W = canvas.clientWidth; H = canvas.clientHeight;
    canvas.width = Math.floor(W*dpr); canvas.height=Math.floor(H*dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  window.addEventListener('resize', resize); resize();

  // ===== WebGazer (gaze) =====
  window.saveDataAcrossSessions = true;
  webgazer.setRegression('ridge').setTracker('TFFacemesh').begin()
    .showVideoPreview(false).showPredictionPoints(false).showFaceFeedbackBox(false);

  let gaze = {x:null,y:null};
  webgazer.setGazeListener((data)=>{
    if(!data) return;
    gaze.x = data.x; gaze.y = data.y;
  });

  // ===== MediaPipe FaceMesh (MAR) =====
  const video = document.createElement('video'); // oculto
  const faceMesh = new FaceMesh.FaceMesh({
    locateFile: (f)=>`https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${f}`
  });
  faceMesh.setOptions({maxNumFaces:1, refineLandmarks:true, minDetectionConfidence:.5, minTrackingConfidence:.5});
  function dist(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }

  let mar = 0;
  faceMesh.onResults(res=>{
    if(!res.multiFaceLandmarks || !res.multiFaceLandmarks.length) return;
    const lm = res.multiFaceLandmarks[0];
    const top=lm[13], bottom=lm[14], left=lm[78], right=lm[308];
    mar = dist(top,bottom)/Math.max(1e-6, dist(left,right));
    marDbg = mar;
    drawing = mar > mouthThr;

    // feedback MAR
    marVal.textContent = mar.toFixed(3);
    const pct = Math.max(0, Math.min(100, (mar/0.8)*100)); // escala tosca 0‚Äì0.8
    marFill.style.width = pct + '%';
    const thrPct = Math.max(0, Math.min(100, (mouthThr/0.8)*100));
    marThr.style.left = thrPct + '%';

    // preview si visible
    if(lmCanvas.style.display !== 'none'){
      const w=lmCanvas.width, h=lmCanvas.height;
      const src = res.image || video;
      lmCtx.drawImage(src, 0, 0, w, h);
      lmCtx.fillStyle="#0f0"; lmCtx.strokeStyle="#0f0"; lmCtx.lineWidth=1;
      function P(p){ return [p.x*w,p.y*h]; }
      const pts=[top,bottom,left,right].map(P);
      for(const p of pts){ lmCtx.beginPath(); lmCtx.arc(p[0],p[1],3,0,Math.PI*2); lmCtx.fill(); }
      lmCtx.beginPath(); lmCtx.moveTo(...pts[0]); lmCtx.lineTo(...pts[1]); lmCtx.stroke();
      lmCtx.beginPath(); lmCtx.moveTo(...pts[2]); lmCtx.lineTo(...pts[3]); lmCtx.stroke();
      lmCtx.fillStyle="#fff"; lmCtx.fillText(`MAR=${mar.toFixed(3)} thr=${mouthThr.toFixed(2)}`,8,14);
    }
  });

  // C√°mara reducida para ahorrar CPU
  let frameCount = 0;
  const camera = new Camera.Camera(video, {
    onFrame: async () => {
      frameCount = (frameCount + 1) || 1;
      if (frameCount % 3 === 0) await faceMesh.send({image: video}); // ~10‚Äì15 fps
    },
    width: 320, height: 240
  });
  camera.start();

  // ===== Dibujo =====
  function step(){
    if(running && gaze.x!=null && gaze.y!=null){
      if(!smoothed) smoothed = {x:gaze.x, y:gaze.y};
      smoothed.x = alpha*gaze.x + (1-alpha)*smoothed.x;
      smoothed.y = alpha*gaze.y + (1-alpha)*smoothed.y;
      // af√≠n
      const tx = A[0]*smoothed.x + A[1]*smoothed.y + b[0];
      const ty = A[2]*smoothed.x + A[3]*smoothed.y + b[1];
      const x = Math.max(0, Math.min(W-1, tx));
      const y = Math.max(0, Math.min(H-1, ty));

      // cursor
      cursor.style.left = x+'px'; cursor.style.top = y+'px';
      cursor.style.width = (brush*2)+'px'; cursor.style.height = (brush*2)+'px';

      if(drawing && last){
        ctx.strokeStyle = 'rgba(0,200,255,.95)';
        ctx.lineWidth = brush; ctx.lineJoin='round'; ctx.lineCap='round';
        ctx.beginPath(); ctx.moveTo(last.x,last.y); ctx.lineTo(x,y); ctx.stroke();
      }
      last = {x,y};
      points.push({t:Date.now(), x, y, mar:marDbg, drawing:drawing?1:0});
      stat.textContent = `pts: ${points.length}`;
    }
    dbg.textContent = `mirada: x=${gaze.x?gaze.x.toFixed(0):'‚Äì'} y=${gaze.y?gaze.y.toFixed(0):'‚Äì'} | MAR=${marDbg?marDbg.toFixed(3):'‚Äì'} | umbral=${mouthThr?mouthThr.toFixed(2):'‚Äì'} | dibujando: ${drawing?'s√≠':'no'}`;
    requestAnimationFrame(step);
  }
  requestAnimationFrame(step);

  // ===== UI =====
  startBtn.onclick = ()=>{ running=true; };
  stopBtn.onclick  = ()=>{ running=false; last=null; };
  clearBtn.onclick = ()=>{ running=false; last=null; smoothed=null; points=[]; ctx.clearRect(0,0,canvas.width,canvas.height); };
  savePng.onclick  = ()=>{ const a=document.createElement('a'); a.download=`gaze_${Date.now()}.png`; a.href=canvas.toDataURL('image/png'); a.click(); };
  saveCsv.onclick  = ()=>{
    const header='t_ms,x,y,mar,drawing\n';
    const body=points.map(p=>`${p.t},${Math.round(p.x)},${Math.round(p.y)},${p.mar.toFixed(4)},${p.drawing}`).join('\n');
    const blob=new Blob([header+body],{type:'text/csv'}); const url=URL.createObjectURL(blob);
    const a=document.createElement('a'); a.href=url; a.download=`gaze_${Date.now()}.csv`; a.click(); URL.revokeObjectURL(url);
  };
  togglePreview.onclick = ()=>{ lmCanvas.style.display = (lmCanvas.style.display==='none'||lmCanvas.style.display==='') ? 'block':'none'; };

  // ===== Calibraci√≥n mirada =====
  calGaze.onclick = async ()=>{
    running=false; last=null; smoothed=null;
    let gazePts=[], tgtPts=[];
    calibMsg.textContent='Mira el punto ~1.6 s cada vez'; calibMsg.style.display='block';
    const targets = [[0.08,0.08],[0.92,0.08],[0.92,0.92],[0.08,0.92],[0.50,0.50]];
    for(const [nx,ny] of targets){
      await showDotAt(nx,ny,1600);
      const {Wv,Hv}=viewportWH();
      const tx=nx*Wv, ty=ny*Hv;
      const samples=[]; await sampleFor(1200, g=>samples.push(g));
      const [gx,gy]=mean2(samples);
      if(!isNaN(gx)&&!isNaN(gy)){ gazePts.push([gx,gy]); tgtPts.push([tx,ty]); }
      await wait(200);
    }
    calibMsg.style.display='none';
    const sol=lsqAffine(gazePts,tgtPts);
    if(sol){ A=sol.A; b=sol.b; alert('Calibraci√≥n de mirada OK ‚úÖ'); }
    else { alert('No se pudo calibrar. Repite mirando bien el punto.'); }
  };

  // ===== Calibraci√≥n boca =====
  calMouth.onclick = async ()=>{
    running=false;
    const closed=[], opened=[];
    calibMsg.textContent='Mant√©n BOCA CERRADA ~2 s'; calibMsg.style.display='block';
    await sampleFor(2000, ()=>{ if(!isNaN(marDbg) && marDbg>0) closed.push(marDbg); });
    await wait(300);
    calibMsg.textContent='Ahora BOCA ABIERTA ~2 s';
    await sampleFor(2000, ()=>{ if(!isNaN(marDbg) && marDbg>0) opened.push(marDbg); });
    calibMsg.style.display='none';
    const mC=median(closed), mO=median(opened);
    if(isFinite(mC)&&isFinite(mO)){
      mouthThr=(mC+mO)/2;
      alert(`Umbral boca fijado: cerrada‚âà${mC.toFixed(3)} | abierta‚âà${mO.toFixed(3)} ‚Üí thr=${mouthThr.toFixed(3)}`);
    } else {
      alert('No se pudo medir MAR. Asegura buena luz y rostro visible.');
    }
  };

  // ===== Utils =====
  function wait(ms){ return new Promise(r=>setTimeout(r,ms)); }
  function viewportWH(){ return {W: window.innerWidth, H: window.innerHeight}; }
  async function showDotAt(nx,ny,holdMs=1600){
    const {W,H}=viewportWH();
    calibDot.style.left = (nx*W)+'px';
    calibDot.style.top  = (ny*H)+'px';
    calibDot.style.display='block';
    await wait(holdMs);
    calibDot.style.display='none';
  }
  async function sampleFor(ms, push){
    const t0=performance.now();
    return new Promise(res=>{
      function loop(){
        const t=performance.now();
        if(gaze.x!=null&&gaze.y!=null) push([gaze.x,gaze.y]);
        if(t-t0<ms) requestAnimationFrame(loop); else res();
      }
      requestAnimationFrame(loop);
    });
  }
  function mean2(arr){ if(!arr.length) return [NaN,NaN]; const sx=arr.reduce((s,v)=>s+v[0],0), sy=arr.reduce((s,v)=>s+v[1],0); return [sx/arr.length, sy/arr.length]; }
  function transpose(A){ const m=A.length,n=A[0].length,AT=Array.from({length:n},()=>Array(m).fill(0)); for(let i=0;i<m;i++) for(let j=0;j<n;j++) AT[j][i]=A[i][j]; return AT; }
  function mul(A,B){ const m=A.length,n=A[0].length,p=B[0].length,C=Array.from({length:m},()=>Array(p).fill(0)); for(let i=0;i<m;i++) for(let k=0;k<n;k++) for(let j=0;j<p;j++) C[i][j]+=A[i][k]*B[k][j]; return C; }
  function mulVec(A,v){ const m=A.length,n=A[0].length,r=Array(m).fill(0); for(let i=0;i<m;i++) for(let j=0;j<n;j++) r[i]+=A[i][j]*v[j]; return r; }
  function solveGaussian(A,b){ const n=A.length,M=A.map((row,i)=>row.concat([b[i]])); for(let i=0;i<n;i++){ let max=i; for(let r=i+1;r<n;r++) if(Math.abs(M[r][i])>Math.abs(M[max][i])) max=r; if(Math.abs(M[max][i])<1e-9) return null; [M[i],M[max]]=[M[max],M[i]]; const piv=M[i][i]; for(let k=i;k<=n;k++) M[i][k]/=piv; for(let r=0;r<n;r++) if(r!==i){ const f=M[r][i]; for(let k=i;k<=n;k++) M[r][k]-=f*M[i][k]; } } return M.map(row=>row[n]); }
  function lsqAffine(gazePts,tgtPts){
    const M=[], Z=[];
    for(let i=0;i<gazePts.length;i++){
      const [gx,gy]=gazePts[i]; const [tx,ty]=tgtPts[i];
      M.push([gx, gy, 0,  0, 1, 0]); Z.push(tx);
      M.push([0,  0, gx, gy, 0, 1]); Z.push(ty);
    }
    const Mt=transpose(M), MtM=mul(Mt,M), MtZ=mulVec(Mt,Z), p=solveGaussian(MtM,MtZ);
    return p ? {A:[p[0],p[1],p[2],p[3]], b:[p[4],p[5]]} : null;
  }
  function median(a){ if(!a.length) return NaN; const s=[...a].sort((x,y)=>x-y); const m=Math.floor(s.length/2); return s.length%2?s[m]:(s[m-1]+s[m])/2; }

  // Atajo debug: tecla D activa/para dibujo manual
  window.addEventListener('keydown', e => { if(e.key==='d'||e.key==='D') drawing=true; });
  window.addEventListener('keyup',   e => { if(e.key==='d'||e.key==='D') drawing=false; });
})();
</script>
</body>
</html>
