<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Diagn√≥stico Boca + Mirada + Brocha (getUserMedia)</title>

<!-- WebGazer (mirada) -->
<script src="https://webgazer.cs.brown.edu/webgazer.js"></script>

<!-- MediaPipe FaceMesh (boca) -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>

<style>
  html, body { margin:0; padding:0; height:100%; overflow:hidden; background:#0f1115; color:#fff; }
  #wrap { position:relative; width:100%; height:100vh; }
  #topbar { position:absolute; top:10px; left:10px; right:10px; display:flex; gap:8px; flex-wrap:wrap;
            background:rgba(0,0,0,.45); padding:8px 10px; border-radius:10px; align-items:center; }
  .btn { appearance:none; border:0; padding:6px 10px; border-radius:10px; cursor:pointer;
         background:#22272e; color:#fff; font-weight:600; }
  .btn.primary { background:#00e676; color:#111; }
  .btn.warn { background:#ff5252; }
  .sp { margin-left:auto; font:12px/1.2 monospace; opacity:.9; }

  #stage { position:absolute; inset:62px 10px 10px 10px; border-radius:10px; background:#10131a; overflow:hidden; }
  #canvas { position:absolute; inset:0; width:100%; height:100%; }
  #cursor { position:absolute; width:20px; height:20px; border:2px solid rgba(255,255,255,.95); border-radius:50%;
            pointer-events:none; transform:translate(-50%,-50%); display:none; }

  #status { position:absolute; bottom:10px; left:10px; right:10px; display:flex; gap:10px; align-items:center;
            background:rgba(255,255,255,.06); padding:8px 10px; border-radius:10px; }
  #modeTag { font-weight:700; background:#1f2937; padding:4px 8px; border-radius:8px; }
  #marPanel{ display:flex; align-items:center; gap:8px; flex:1; }
  #marBar{ position:relative; height:10px; flex:1; background:#2b2f3a; border-radius:6px; overflow:hidden; }
  #marFill{ position:absolute; top:0; left:0; height:100%; width:0%; background:#00e676; }
  #marThr{ position:absolute; top:-3px; width:2px; height:16px; background:#ff5252; left:50%; }
  #marVal { min-width:72px; text-align:right; font:12px/1 monospace; opacity:.9; }

  #preview { position:absolute; top:10px; right:10px; width:300px; height:225px; background:#000a; border-radius:8px; display:none; }
  video#rawVideo { display:none; } /* video real, oculto; lo pintamos en #preview */
</style>
</head>
<body>
<div id="wrap">
  <div id="topbar">
    <button id="testCam" class="btn">üé• Probar c√°mara (getUserMedia)</button>
    <button id="modeFace" class="btn">1) Test de Boca</button>
    <button id="modeGaze" class="btn">2) Test de Mirada</button>
    <button id="modeBrush" class="btn primary">3) Iniciar Brocha</button>
    <button id="calGaze" class="btn">üéØ Calibrar mirada</button>
    <button id="calMouth" class="btn">üëÑ Calibrar boca</button>
    <button id="togglePreview" class="btn">üëÅÔ∏è Preview</button>
    <button id="clear" class="btn warn">üßπ Limpiar</button>
    <button id="savePng" class="btn">üñºÔ∏è PNG</button>
    <button id="saveCsv" class="btn">üìÑ CSV</button>
    <span class="sp" id="count">pts: 0</span>
  </div>

  <div id="stage">
    <canvas id="canvas"></canvas>
    <div id="cursor"></div>
    <canvas id="preview"></canvas>
    <video id="rawVideo" playsinline autoplay muted></video>
  </div>

  <div id="status">
    <span id="modeTag">Modo: ‚Äî</span>
    <div id="marPanel">
      <span>MAR:</span>
      <div id="marBar"><div id="marFill"></div><div id="marThr"></div></div>
      <span id="marVal">‚Äî</span>
    </div>
  </div>
</div>

<script>
(function(){
  const cfg = window.DIAG_CFG || { brush:8, alpha:.45, mouthThr:.28, debug:true };

  // DOM
  const canvas = document.getElementById('canvas'); const ctx = canvas.getContext('2d');
  const cursor = document.getElementById('cursor');
  const preview = document.getElementById('preview'); const pctx = preview.getContext('2d');
  const rawVideo = document.getElementById('rawVideo');

  const testCamBtn = document.getElementById('testCam');
  const modeFaceBtn = document.getElementById('modeFace');
  const modeGazeBtn = document.getElementById('modeGaze');
  const modeBrushBtn= document.getElementById('modeBrush');
  const calGazeBtn  = document.getElementById('calGaze');
  const calMouthBtn = document.getElementById('calMouth');
  const togglePrev  = document.getElementById('togglePreview');
  const clearBtn    = document.getElementById('clear');
  const savePngBtn  = document.getElementById('savePng');
  const saveCsvBtn  = document.getElementById('saveCsv');

  const countEl = document.getElementById('count');
  const modeTag = document.getElementById('modeTag');

  const marFill = document.getElementById('marFill');
  const marThr  = document.getElementById('marThr');
  const marVal  = document.getElementById('marVal');

  // State
  let W=0,H=0,dpr=1;
  let mode='face';
  let drawing=false;
  let running=true;
  let brush = cfg.brush;
  let alpha = cfg.alpha;
  let mouthThr = cfg.mouthThr;
  let smoothed=null, last=null;
  let pts=[];

  // Af√≠n de mirada
  let A=[1,0,0,1], b=[0,0];

  function resize(){
    dpr = Math.min(window.devicePixelRatio||1, 2);
    const r = document.getElementById('stage').getBoundingClientRect();
    canvas.width = Math.floor(r.width*dpr); canvas.height=Math.floor(r.height*dpr);
    canvas.style.width=r.width+'px'; canvas.style.height=r.height+'px';
    ctx.setTransform(dpr,0,0,dpr,0,0);
    preview.width = Math.floor(300*dpr); preview.height=Math.floor(225*dpr);
    preview.style.width='300px'; preview.style.height='225px';
    pctx.setTransform(dpr,0,0,dpr,0,0);
    W=r.width; H=r.height;
  }
  window.addEventListener('resize', resize); resize();

  // ========== getUserMedia: iniciar c√°mara manualmente ==========
  let gStream = null;
  async function startCamera(){
    try{
      // pide c√°mara frontal si est√° en m√≥vil; en desktop cualquier c√°mara por defecto
      gStream = await navigator.mediaDevices.getUserMedia({ video: { width: 640, height: 480 } });
      rawVideo.srcObject = gStream;
      await rawVideo.play();
      alert('‚úÖ C√°mara iniciada (getUserMedia).');
    }catch(e){
      console.error('getUserMedia error', e);
      alert('‚ùå No se pudo iniciar la c√°mara: ' + (e.name||'') + ' ‚Äî ' + (e.message||''));
    }
  }
  testCamBtn.onclick = startCamera;

  // ====== MediaPipe FaceMesh usando frames del rawVideo ======
  const faceMesh = new FaceMesh.FaceMesh({
    locateFile: (f)=>`https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${f}`
  });
  faceMesh.setOptions({ maxNumFaces:1, refineLandmarks:true, minDetectionConfidence:.5, minTrackingConfidence:.5 });

  function dist(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }
  let mar=0, marDbg=0;

  async function faceLoop(){
    if (rawVideo.readyState >= 2 && !rawVideo.paused && !rawVideo.ended){
      // Enviar el frame actual a FaceMesh
      await faceMesh.send({ image: rawVideo });
    }
    requestAnimationFrame(faceLoop);
  }
  faceMesh.onResults(res=>{
    if(!res.multiFaceLandmarks || !res.multiFaceLandmarks.length) return;
    const lm = res.multiFaceLandmarks[0];
    const top=lm[13], bottom=lm[14], left=lm[78], right=lm[308];
    mar = dist(top,bottom)/Math.max(1e-6, dist(left,right));
    marDbg = mar;

    // Feedback MAR
    marVal.textContent = mar.toFixed(3);
    const pct = Math.max(0, Math.min(1, mar/0.8))*100;
    marFill.style.width = pct.toFixed(0)+'%';
    marThr.style.left   = (Math.max(0, Math.min(1, mouthThr/0.8))*100).toFixed(0)+'%';

    // Preview (si visible)
    if(preview.style.display !== 'none'){
      pctx.clearRect(0,0,preview.width,preview.height);
      pctx.drawImage(rawVideo, 0, 0, preview.width, preview.height);
      // landmarks principales (aprox)
      pctx.fillStyle='#0f0'; pctx.strokeStyle='#0f0'; pctx.lineWidth=1;
      function P(p){ return [p.x*preview.width, p.y*preview.height]; }
      const ptsL=[top,bottom,left,right].map(P);
      for(const p of ptsL){ pctx.beginPath(); pctx.arc(p[0],p[1],3,0,Math.PI*2); pctx.fill(); }
      pctx.beginPath(); pctx.moveTo(...ptsL[0]); pctx.lineTo(...ptsL[1]); pctx.stroke();
      pctx.beginPath(); pctx.moveTo(...ptsL[2]); pctx.lineTo(...ptsL[3]); pctx.stroke();
      pctx.fillStyle='#fff'; pctx.fillText(`MAR=${mar.toFixed(3)} thr=${mouthThr.toFixed(2)}`, 8, 14);
    }
  });

  // ====== WebGazer (mirada) ======
  window.saveDataAcrossSessions = true;
  webgazer.setRegression('ridge').setTracker('TFFacemesh').begin()
    .showVideoPreview(false).showPredictionPoints(false).showFaceFeedbackBox(false);

  let gaze = {x:null,y:null};
  webgazer.setGazeListener((data)=>{ if(data){ gaze.x=data.x; gaze.y=data.y; } });

  // ====== Dibujo ======
  function mainLoop(){
    // Mover cursor y dibujar seg√∫n modo
    if(gaze.x!=null && gaze.y!=null){
      if(!smoothed) smoothed = {x:gaze.x, y:gaze.y};
      smoothed.x = alpha*gaze.x + (1-alpha)*smoothed.x;
      smoothed.y = alpha*gaze.y + (1-alpha)*smoothed.y;

      const tx = A[0]*smoothed.x + A[1]*smoothed.y + b[0];
      const ty = A[2]*smoothed.x + A[3]*smoothed.y + b[1];
      const x = Math.max(0, Math.min(W-1, tx));
      const y = Math.max(0, Math.min(H-1, ty));

      if(mode==='gaze' || mode==='brush'){
        cursor.style.display='block';
        cursor.style.left=x+'px'; cursor.style.top=y+'px';
        cursor.style.width=(cfg.brush*2)+'px'; cursor.style.height=(cfg.brush*2)+'px';
      } else {
        cursor.style.display='none';
      }

      if(mode==='brush' && marDbg>mouthThr){
        if(last){
          ctx.strokeStyle='rgba(0,200,255,.95)';
          ctx.lineWidth=cfg.brush; ctx.lineJoin='round'; ctx.lineCap='round';
          ctx.beginPath(); ctx.moveTo(last.x,last.y); ctx.lineTo(x,y); ctx.stroke();
          pts.push({t:Date.now(), x, y, mar:marDbg, drawing:1});
          countEl.textContent = `pts: ${pts.length}`;
        }
      }
      last = {x,y};
    }
    requestAnimationFrame(mainLoop);
  }

  // ====== Modos ======
  function setMode(m){
    mode = m;
    modeTag.textContent = 'Modo: ' + (m==='face'?'Test de Boca': m==='gaze'?'Test de Mirada':'Brocha');
  }
  setMode('face');

  modeFaceBtn.onclick = ()=> setMode('face');
  modeGazeBtn.onclick = ()=> setMode('gaze');
  modeBrushBtn.onclick= ()=> setMode('brush');

  // ====== Calibraci√≥n mirada ======
  calGazeBtn.onclick = async ()=>{
    const targets = [[0.08,0.08],[0.92,0.08],[0.92,0.92],[0.08,0.92],[0.50,0.50]];
    let gazePts=[], tgtPts=[];
    alert('Calibraci√≥n: mira esquinas y centro (1.6 s cada una).');
    for(const [nx,ny] of targets){
      const r = document.getElementById('stage').getBoundingClientRect();
      const tx = nx*r.width, ty = ny*r.height;
      const samples=[]; const t0=performance.now();
      await new Promise(res=>{ function loop(){ const t=performance.now();
        if(gaze.x!=null&&gaze.y!=null) samples.push([gaze.x,gaze.y]);
        if(t-t0<1600) requestAnimationFrame(loop); else res();
      } requestAnimationFrame(loop); });
      const [gx,gy] = mean2(samples);
      if(!isNaN(gx)&&!isNaN(gy)){ gazePts.push([gx,gy]); tgtPts.push([tx,ty]); }
      await sleep(200);
    }
    const sol = lsqAffine(gazePts, tgtPts);
    if(sol){ A=sol.A; b=sol.b; alert('Calibraci√≥n de mirada OK ‚úÖ'); }
    else { alert('No se pudo calibrar. Repite mirando bien los puntos.'); }
  };

  // ====== Calibraci√≥n boca ======
  calMouthBtn.onclick = async ()=>{
    alert('Calibraci√≥n de boca: 2 s cerrada ‚Üí 2 s abierta.');
    const closed=[], opened=[];
    // cerrada
    const t0=performance.now();
    await new Promise(res=>{ function loop(){ const t=performance.now();
      if(!isNaN(marDbg) && marDbg>0) closed.push(marDbg);
      if(t-t0<2000) requestAnimationFrame(loop); else res();
    } requestAnimationFrame(loop); });
    await sleep(300);
    // abierta
    const t1=performance.now();
    await new Promise(res=>{ function loop(){ const t=performance.now();
      if(!isNaN(marDbg) && marDbg>0) opened.push(marDbg);
      if(t-t1<2000) requestAnimationFrame(loop); else res();
    } requestAnimationFrame(loop); });
    const mC=median(closed), mO=median(opened);
    if(isFinite(mC)&&isFinite(mO)){
      mouthThr=(mC+mO)/2;
      alert(`Umbral fijado: cerrada‚âà${mC.toFixed(3)} | abierta‚âà${mO.toFixed(3)} ‚Üí thr=${mouthThr.toFixed(3)}`);
      marThr.style.left=(Math.max(0,Math.min(1,mouthThr/0.8))*100).toFixed(0)+'%';
    } else {
      alert('No se pudo medir MAR. Mejora iluminaci√≥n y repite.');
    }
  };

  // ====== Otros controles ======
  togglePrev.onclick = ()=>{
    preview.style.display = (preview.style.display==='none'||preview.style.display==='') ? 'block':'none';
  };
  clearBtn.onclick = ()=>{
    ctx.clearRect(0,0,canvas.width,canvas.height);
    pts=[]; countEl.textContent='pts: 0'; last=null; smoothed=null;
  };
  savePngBtn.onclick = ()=>{
    const a=document.createElement('a');
    a.download = `brocha_${Date.now()}.png`;
    a.href = canvas.toDataURL('image/png');
    a.click();
  };
  saveCsvBtn.onclick = ()=>{
    const header='t_ms,x,y,mar,drawing\n';
    const body=pts.map(p=>`${p.t},${Math.round(p.x)},${Math.round(p.y)},${p.mar?.toFixed?.(4)??0},${p.drawing||0}`).join('\\n');
    const blob=new Blob([header+body],{type:'text/csv'});
    const url=URL.createObjectURL(blob);
    const a=document.createElement('a'); a.href=url; a.download=`brocha_${Date.now()}.csv`; a.click();
    URL.revokeObjectURL(url);
  };

  // ====== Utils ======
  function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }
  function mean2(arr){ if(!arr.length) return [NaN,NaN]; const sx=arr.reduce((s,v)=>s+v[0],0), sy=arr.reduce((s,v)=>s+v[1],0); return [sx/arr.length, sy/arr.length]; }
  function transpose(A){ const m=A.length,n=A[0].length,AT=Array.from({length:n},()=>Array(m).fill(0)); for(let i=0;i<m;i++) for(let j=0;j<n;j++) AT[j][i]=A[i][j]; return AT; }
  function mul(A,B){ const m=A.length,n=A[0].length,p=B[0].length,C=Array.from({length:m},()=>Array(p).fill(0)); for(let i=0;i<m;i++) for(let k=0;k<n;k++) for(let j=0;j<p;j++) C[i][j]+=A[i][k]*B[k][j]; return C; }
  function mulVec(A,v){ const m=A.length,n=A[0].length,r=Array(m).fill(0); for(let i=0;i<m;i++) for(let j=0;j<n;j++) r[i]+=A[i][j]*v[j]; return r; }
  function solveGaussian(A,b){
    const n=A.length,M=A.map((row,i)=>row.concat([b[i]]));
    for(let i=0;i<n;i++){
      let max=i; for(let r=i+1;r<n;r++) if(Math.abs(M[r][i])>Math.abs(M[max][i])) max=r;
      if(Math.abs(M[max][i])<1e-9) return null;
      [M[i],M[max]]=[M[max],M[i]];
      const piv=M[i][i];
      for(let k=i;k<=n;k++) M[i][k]/=piv;
      for(let r=0;r<n;r++) if(r!==i){
        const f=M[r][i]; for(let k=i;k<=n;k++) M[r][k]-=f*M[i][k];
      }
    }
    return M.map(row=>row[n]);
  }
  function lsqAffine(gazePts,tgtPts){
    const M=[], Z=[];
    for(let i=0;i<gazePts.length;i++){
      const [gx,gy]=gazePts[i]; const [tx,ty]=tgtPts[i];
      M.push([gx, gy, 0,  0, 1, 0]); Z.push(tx);
      M.push([0,  0, gx, gy, 0, 1]); Z.push(ty);
    }
    const Mt=transpose(M), MtM=mul(Mt,M), MtZ=mulVec(Mt,Z), p=solveGaussian(MtM,MtZ);
    return p ? {A:[p[0],p[1],p[2],p[3]], b:[p[4],p[5]]} : null;
  }

  // Atajo debug: tecla D simula ‚Äúboca abierta‚Äù
  window.addEventListener('keydown', e=>{ if(e.key==='d'||e.key==='D') drawing=true; });
  window.addEventListener('keyup',   e=>{ if(e.key==='d'||e.key==='D') drawing=false; });

  // Arranques de loops
  requestAnimationFrame(mainLoop);
  requestAnimationFrame(faceLoop);
})();
</script>
</body>
</html>
