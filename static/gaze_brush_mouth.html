
<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Gaze Brush Mouth</title>
<!-- WebGazer for gaze -->
<script src="https://webgazer.cs.brown.edu/webgazer.js"></script>
<!-- MediaPipe FaceMesh (via CDN) -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
<style>
  html, body { margin:0; padding:0; height:100%; overflow:hidden; background:#111; }
  #wrap { position:relative; width:100%; height:100vh; }
  #canvas { position:absolute; inset:0; width:100%; height:100%; background:#111; }
  #cursor { position:absolute; width:16px; height:16px; border-radius:50%; pointer-events:none;
            border:2px solid rgba(255,255,255,.8); transform:translate(-50%,-50%); }
  #hud { position:absolute; top:10px; left:10px; right:10px; display:flex; gap:8px; flex-wrap:wrap;
         background:rgba(0,0,0,.55); color:#fff; padding:8px 10px; border-radius:10px;
         font:12px/1.3 ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial; }
  .btn { appearance:none; border:0; padding:6px 10px; border-radius:10px; cursor:pointer;
         background:#222; color:#fff; font-weight:600; }
  .btn.primary { background:#00e676; color:#111; }
  .btn.warn { background:#ff5252; }
  #stat { margin-left:auto; font-family:monospace; }
  #dbg { position:absolute; bottom:10px; left:10px; color:#fff; font:12px monospace; }
  #webgazerVideoContainer { display:none !important; } /* ocultar previsualizaci√≥n por defecto */
  video#inputVideo { display:none; } /* video de MediaPipe oculto */
  canvas#landmarks { position:absolute; top:0; right:0; width:240px; height:180px; background:#0008; display:none; }
</style>
</head>
<body>
<div id="wrap">
  <canvas id="canvas"></canvas>
  <div id="cursor"></div>
  <div id="hud">
    <button id="start" class="btn primary">‚ñ∂Ô∏è Iniciar</button>
    <button id="stop" class="btn">‚è∏Ô∏è Pausar</button>
    <button id="clear" class="btn warn">üßπ Limpiar</button>
    <button id="savePng" class="btn">üñºÔ∏è PNG</button>
    <button id="saveCsv" class="btn">üìÑ CSV</button>
    <span id="stat">‚Äî</span>
  </div>
  <div id="dbg">mirada: x=‚Äì y=‚Äì | MAR=‚Äì | dibujando: no</div>
  <video id="inputVideo" playsinline></video>
  <canvas id="landmarks"></canvas>
</div>

<script>
(async function(){
  const cfg = window.GAZE_BRUSH_CONFIG || {brush: 6, alpha: .4, mouthThr: .28, debug: false};
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const cursor = document.getElementById('cursor');
  const stat = document.getElementById('stat');
  const dbg = document.getElementById('dbg');
  const startBtn = document.getElementById('start');
  const stopBtn = document.getElementById('stop');
  const clearBtn = document.getElementById('clear');
  const savePng = document.getElementById('savePng');
  const saveCsv = document.getElementById('saveCsv');
  const inputVideo = document.getElementById('inputVideo');
  const lmCanvas = document.getElementById('landmarks');
  const lmCtx = lmCanvas.getContext('2d');
  lmCanvas.style.display = cfg.debug ? 'block' : 'none';

  let W=0,H=0, running=false;
  let alpha = cfg.alpha;
  let brush = cfg.brush;
  let mouthThr = cfg.mouthThr;
  let smoothed = null, last = null;
  let drawing = false; // estado: dibujar cuando boca abierta
  const pts = []; // {t,x,y,mar,drawing}

  function resize(){
    const dpr = Math.min(window.devicePixelRatio || 1, 2);
    W = canvas.clientWidth;
    H = canvas.clientHeight;
    canvas.width = Math.floor(W * dpr);
    canvas.height = Math.floor(H * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
    redraw();
  }
  function redraw(){
    // no limpiar para mantener el trazo al redimensionar
  }
  window.addEventListener('resize', resize);
  resize();

  // WebGazer: mirada
  window.saveDataAcrossSessions = true;
  webgazer.setRegression('ridge')
    .setTracker('TFFacemesh')
    .begin()
    .showVideoPreview(false)
    .showPredictionPoints(false)
    .showFaceFeedbackBox(false);

  let gaze = {x: null, y: null};
  webgazer.setGazeListener((data, elapsedTime)=>{
    if(!data) return;
    gaze.x = data.x;
    gaze.y = data.y;
  });

  // MediaPipe FaceMesh: calcular MAR (Mouth Aspect Ratio)
  // Usamos algunos landmarks de labios (√≠ndices del modelo MediaPipe)
  // superiores (13, 0), inferiores (14, 17), extremos (78, 308) approx
  function dist(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }

  const faceMesh = new FaceMesh.FaceMesh({
    locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`
  });
  faceMesh.setOptions({
    maxNumFaces: 1,
    refineLandmarks: true,
    minDetectionConfidence: 0.5,
    minTrackingConfidence: 0.5
  });

  faceMesh.onResults(results => {
    if(!results.multiFaceLandmarks || results.multiFaceLandmarks.length===0) return;
    const lm = results.multiFaceLandmarks[0];
    // Calcular MAR: apertura vertical / ancho horizontal
    const top = lm[13];   // upper inner lip
    const bottom = lm[14];// lower inner lip
    const left = lm[78];  // mouth left
    const right = lm[308];// mouth right
    const mar = dist(top,bottom) / Math.max(1e-6, dist(left,right));
    drawing = mar > mouthThr;

    if(cfg.debug){
      lmCtx.clearRect(0,0,lmCanvas.width,lmCanvas.height);
      lmCtx.fillStyle = "#0f0"; lmCtx.strokeStyle="#0f0"; lmCtx.lineWidth=1;
      const w = lmCanvas.width, h = lmCanvas.height;
      function P(p){ return [p.x*w, p.y*h]; }
      const ptsD = [top,bottom,left,right].map(P);
      for(const p of ptsD){ lmCtx.beginPath(); lmCtx.arc(p[0],p[1],3,0,Math.PI*2); lmCtx.fill(); }
      lmCtx.beginPath(); lmCtx.moveTo(...ptsD[0]); lmCtx.lineTo(...ptsD[1]); lmCtx.stroke();
      lmCtx.beginPath(); lmCtx.moveTo(...ptsD[2]); lmCtx.lineTo(...ptsD[3]); lmCtx.stroke();
      lmCtx.fillStyle = "#fff";
      lmCtx.fillText(`MAR=${mar.toFixed(3)} thr=${mouthThr.toFixed(2)}`, 8, 16);
    }

    // HUD
    dbg.textContent = `mirada: x=${gaze.x?gaze.x.toFixed(0):'‚Äì'} y=${gaze.y?gaze.y.toFixed(0):'‚Äì'} | MAR=${mar.toFixed(3)} | dibujando: ${drawing?'s√≠':'no'}`;
  });

  // Iniciar c√°mara para MediaPipe
  const camera = new Camera.Camera(inputVideo, {
    onFrame: async () => { await faceMesh.send({image: inputVideo}); },
    width: 640, height: 480
  });
  camera.start();

  function step(){
    if(running){
      if(gaze.x!=null && gaze.y!=null){
        if(!smoothed) smoothed = {x:gaze.x, y:gaze.y};
        smoothed.x = alpha * gaze.x + (1-alpha) * smoothed.x;
        smoothed.y = alpha * gaze.y + (1-alpha) * smoothed.y;
        const x = Math.max(0, Math.min(W-1, smoothed.x));
        const y = Math.max(0, Math.min(H-1, smoothed.y));

        // mover cursor
        cursor.style.left = x + 'px';
        cursor.style.top  = y + 'px';
        cursor.style.width = (brush*2) + 'px';
        cursor.style.height= (brush*2) + 'px';

        if(drawing && last){
          ctx.strokeStyle = 'rgba(0,200,255,0.95)';
          ctx.lineWidth = brush;
          ctx.lineJoin = 'round';
          ctx.lineCap = 'round';
          ctx.beginPath();
          ctx.moveTo(last.x, last.y);
          ctx.lineTo(x, y);
          ctx.stroke();
        }
        last = {x,y};
        pts.push({t: Date.now(), x, y, drawing: drawing?1:0});
        stat.textContent = `pts: ${pts.length}`;
      }
    }
    requestAnimationFrame(step);
  }
  requestAnimationFrame(step);

  // UI
  startBtn.addEventListener('click', ()=>{ running=true; });
  stopBtn.addEventListener('click',  ()=>{ running=false; last=null; });
  clearBtn.addEventListener('click', ()=>{
    running=false; last=null; smoothed=null; pts.length=0;
    ctx.clearRect(0,0,canvas.width,canvas.height);
  });
  savePng.addEventListener('click', ()=>{
    const a = document.createElement('a');
    a.download = `gaze_brush_${Date.now()}.png`;
    a.href = canvas.toDataURL('image/png');
    a.click();
  });
  function toCsv(rows){
    const header = 't_ms,x,y,drawing\n';
    const body = rows.map(r => `${r.t},${Math.round(r.x)},${Math.round(r.y)},${r.drawing}`).join('\n');
    return header + body;
  }
  saveCsv.addEventListener('click', ()=>{
    const blob = new Blob([toCsv(pts)], {type:'text/csv'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `gaze_points_${Date.now()}.csv`;
    a.click();
    URL.revokeObjectURL(url);
  });

  // Resize observer to set canvas logical size
  const ro = new ResizeObserver(entries=>{
    for(const e of entries){
      const r = e.contentRect;
      canvas.width = r.width * Math.min(window.devicePixelRatio||1,2);
      canvas.height= r.height* Math.min(window.devicePixelRatio||1,2);
      ctx.setTransform(Math.min(window.devicePixelRatio||1,2),0,0,Math.min(window.devicePixelRatio||1,2),0,0);
    }
  });
  ro.observe(canvas);

})();
</script>
</body>
</html>
