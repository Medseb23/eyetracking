<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Diagn√≥stico Mirada + Nariz (getUserMedia)</title>

<!-- WebGazer (mirada) -->
<script src="https://webgazer.cs.brown.edu/webgazer.js"></script>
<!-- MediaPipe FaceMesh -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh"></script>

<style>
  html,body{margin:0;padding:0;height:100%;overflow:hidden;background:#0f1115;color:#fff}
  #wrap{position:relative;width:100%;height:100vh}
  #topbar{position:absolute;top:10px;left:10px;right:10px;display:flex;gap:8px;flex-wrap:wrap;
          background:rgba(0,0,0,.45);padding:8px 10px;border-radius:10px;align-items:center;z-index:10000}
  .btn{appearance:none;border:0;padding:6px 10px;border-radius:10px;cursor:pointer;background:#22272e;color:#fff;font-weight:600}
  .btn.primary{background:#00e676;color:#111}
  .btn.warn{background:#ff5252}
  .sp{margin-left:auto;font:12px/1.2 monospace;opacity:.9}
  #stage{position:absolute;inset:62px 10px 10px 10px;border-radius:10px;background:#10131a;overflow:hidden}
  #canvas{position:absolute;inset:0;width:100%;height:100%}
  #cursor{position:absolute;width:20px;height:20px;border:2px solid rgba(255,255,255,.95);border-radius:50%;
          pointer-events:none;transform:translate(-50%,-50%);display:none}
  #status{position:absolute;bottom:10px;left:10px;right:10px;display:flex;gap:10px;align-items:center;
          background:rgba(255,255,255,.06);padding:8px 10px;border-radius:10px;z-index:9999}
  #modeTag{font-weight:700;background:#1f2937;padding:4px 8px;border-radius:8px}
  #marPanel{display:flex;align-items:center;gap:8px;flex:1}
  #marBar{position:relative;height:10px;flex:1;background:#2b2f3a;border-radius:6px;overflow:hidden}
  #marFill{position:absolute;top:0;left:0;height:100%;width:0%;background:#00e676}
  #marThr{position:absolute;top:-3px;width:2px;height:16px;background:#ff5252;left:50%}
  #marVal{min-width:90px;text-align:right;font:12px/1 monospace;opacity:.9}
  #preview{position:absolute;top:10px;right:10px;width:300px;height:225px;background:#000a;border-radius:8px;display:none;z-index:5000}
  video#rawVideo{display:none}
  #errbar{position:absolute;bottom:0;left:0;right:0;background:#ff3344;color:#100;padding:6px 10px;font:12px/1.3 monospace;
          display:none;z-index:10001}
</style>
</head>
<body>
<div id="wrap">
  <div id="topbar">
    <button id="testCam" class="btn">üé• Probar c√°mara</button>
    <button id="modeFace" class="btn">1) Test de Nariz</button>
    <button id="modeGaze" class="btn">2) Test de Mirada</button>
    <button id="modeBrush" class="btn primary">3) Iniciar Brocha</button>
    <button id="calGaze" class="btn">üéØ Calibrar mirada</button>
    <button id="calNose" class="btn">üëÉ Calibrar nariz</button>
    <button id="togglePreview" class="btn">üëÅÔ∏è Preview</button>
    <button id="clear" class="btn warn">üßπ Limpiar</button>
    <button id="savePng" class="btn">üñºÔ∏è PNG</button>
    <button id="saveCsv" class="btn">üìÑ CSV</button>
    <span class="sp" id="count">pts: 0</span>
  </div>

  <div id="stage">
    <canvas id="canvas"></canvas>
    <div id="cursor"></div>
    <canvas id="preview"></canvas>
    <video id="rawVideo" playsinline autoplay muted></video>
  </div>

  <div id="status">
    <span id="modeTag">Modo: Test de Nariz</span>
    <div id="marPanel">
      <span>NZ:</span>
      <div id="marBar"><div id="marFill"></div><div id="marThr"></div></div>
      <span id="marVal">‚Äî</span>
    </div>
  </div>

  <div id="errbar"></div>
</div>

<script>
(function(){
  // ---- errores visibles ----
  const errbar=document.getElementById('errbar');
  function showErr(msg){ errbar.textContent='‚ö†Ô∏è '+msg; errbar.style.display='block'; }
  window.onerror=(m,src,l,c)=>showErr((m||'Error')+(l?` @${l}:${c||0}`:''));
  window.onunhandledrejection=(ev)=>showErr('Promise rejection: '+(ev.reason?.message||ev.reason||''));

  // ---- DOM ----
  const stageEl=document.getElementById('stage');
  const canvas=document.getElementById('canvas'); const ctx=canvas.getContext('2d');
  const cursor=document.getElementById('cursor');
  const preview=document.getElementById('preview'); const pctx=preview.getContext('2d');
  const rawVideo=document.getElementById('rawVideo');
  const countEl=document.getElementById('count');
  const modeTag=document.getElementById('modeTag');
  const nzVal=document.getElementById('marVal'); const nzFill=document.getElementById('marFill'); const nzThrEl=document.getElementById('marThr');

  // ---- estado ----
  let mode='face'; // 'face' | 'gaze' | 'brush'
  let brush=(window.DIAG_CFG?.brush)||8;
  let alpha=(window.DIAG_CFG?.alpha)||.45;
  let dpr=1, W=0, H=0;
  let pts=[], last=null, smoothed=null;

  // Nose depth (Z): valores negativos hacia la c√°mara.
  let noseZ = 0;          // valor actual
  let noseZNeutral = 0;   // referencia calibrada (reposo)
  let noseDelta = 0.02;   // cu√°nto ‚Äúempujar‚Äù para activar (ajustable)
  // Dibuja cuando: noseZ < (noseZNeutral - noseDelta)
  function noseActive(){ return noseZ < (noseZNeutral - noseDelta); }

  // Af√≠n de mirada
  let A=[1,0,0,1], b=[0,0];
  let gaze={x:null,y:null};

  // ---- tama√±o ----
  function resize(){
    dpr=Math.min(window.devicePixelRatio||1,2);
    const r=stageEl.getBoundingClientRect();
    canvas.width=Math.floor(r.width*dpr); canvas.height=Math.floor(r.height*dpr);
    canvas.style.width=r.width+'px'; canvas.style.height=r.height+'px';
    ctx.setTransform(dpr,0,0,dpr,0,0);
    preview.width=Math.floor(300*dpr); preview.height=Math.floor(225*dpr);
    preview.style.width='300px'; preview.style.height='225px';
    pctx.setTransform(dpr,0,0,dpr,0,0);
    W=r.width; H=r.height;
  }
  window.addEventListener('resize', resize); resize();

  // ---- UI ----
  document.getElementById('modeFace').onclick=()=>setMode('face');
  document.getElementById('modeGaze').onclick=()=>setMode('gaze');
  document.getElementById('modeBrush').onclick=()=>setMode('brush');
  document.getElementById('togglePreview').onclick=()=>{preview.style.display=(preview.style.display==='none'||preview.style.display==='')?'block':'none';};
  document.getElementById('clear').onclick=()=>{ctx.clearRect(0,0,canvas.width,canvas.height); pts=[]; countEl.textContent='pts: 0'; last=null; smoothed=null;};
  document.getElementById('savePng').onclick=()=>{const a=document.createElement('a'); a.download=`brocha_${Date.now()}.png`; a.href=canvas.toDataURL('image/png'); a.click();};
  document.getElementById('saveCsv').onclick=()=>{const header='t_ms,x,y,nz,active\n'; const body=pts.map(p=>`${p.t},${Math.round(p.x)},${Math.round(p.y)},${p.nz?.toFixed?.(4)??0},${p.active?1:0}`).join('\n'); const blob=new Blob([header+body],{type:'text/csv'}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download=`brocha_nariz_${Date.now()}.csv`; a.click(); URL.revokeObjectURL(url);};

  function setMode(m){
    mode=m;
    modeTag.textContent = 'Modo: ' + (m==='face'?'Test de Nariz': m==='gaze'?'Test de Mirada':'Brocha');
    if(m==='face') cursor.style.display='none';
  }

  // ---- C√°mara ----
  let gStream=null;
  document.getElementById('testCam').onclick=async ()=>{
    try{
      gStream=await navigator.mediaDevices.getUserMedia({video:{width:640,height:480}});
      rawVideo.srcObject=gStream; await rawVideo.play(); errbar.style.display='none';
      alert('‚úÖ C√°mara iniciada.');
    }catch(e){ showErr('getUserMedia: '+(e.name||'')+' ‚Äî '+(e.message||'')); }
  };

  // ---- FaceMesh (principal + nariz) ----
  const faceMesh=new FaceMesh({ locateFile:(f)=>`https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${f}` });
  faceMesh.setOptions({maxNumFaces:3, refineLandmarks:true, minDetectionConfidence:.5, minTrackingConfidence:.5});

  // indices candidatos para nariz (tip/bridge). Usamos 1 o 4 seg√∫n modelo; probamos ambos y elegimos el que est√© m√°s ‚Äúsalido‚Äù.
  const NOSE_IDX = [1, 4];

  function dist(a,b){const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy);}
  function bboxOf(lm){let minx=1,miny=1,maxx=0,maxy=0; for(const p of lm){ if(p.x<minx)minx=p.x; if(p.y<miny)miny=p.y; if(p.x>maxx)maxx=p.x; if(p.y>maxy)maxy=p.y; } return {minx,miny,maxx,maxy,cx:(minx+maxx)/2,cy:(miny+maxy)/2,area:(maxx-minx)*(maxy-miny)};}
  function pickMainFace(arr){ if(!arr||!arr.length) return null; let best=0,score=Infinity; for(let i=0;i<arr.length;i++){ const bb=bboxOf(arr[i]); const dc=(bb.cx-0.5)**2+(bb.cy-0.5)**2; const s=dc/(bb.area+1e-6); if(s<score){score=s;best=i;} } return arr[best]; }

  async function faceLoop(){
    try{
      if(rawVideo.readyState>=2 && !rawVideo.paused && !rawVideo.ended){
        await faceMesh.send({image:rawVideo});
      }
    }catch(e){ showErr('faceLoop: '+e.message); }
    requestAnimationFrame(faceLoop);
  }

  faceMesh.onResults(res=>{
    if(!res.multiFaceLandmarks || !res.multiFaceLandmarks.length) return;
    const main = pickMainFace(res.multiFaceLandmarks);
    if(!main) return;

    // elegir punto de nariz con menor z (m√°s cerca de la c√°mara)
    let nose = main[NOSE_IDX[0]];
    for(const idx of NOSE_IDX){ if(main[idx] && main[idx].z < nose.z) nose = main[idx]; }
    noseZ = nose.z; // ojo: valores negativos son m√°s cerca de la c√°mara

    // feedback NZ
    nzVal.textContent = noseZ.toFixed(4);
    // bar: mapeamos z [-0.2, 0.2] -> [0,100] aprox
    const norm = Math.max(0, Math.min(1, (0.2 - (noseZ - (-0.2))) / 0.4 )); // simple hack visual
    nzFill.style.width = (norm*100).toFixed(0)+'%';
    // umbral visual
    const thrZ = noseZNeutral - noseDelta;
    const thrPct = Math.max(0, Math.min(1, (0.2 - (thrZ - (-0.2))) / 0.4 ));
    nzThrEl.style.left = (thrPct*100).toFixed(0)+'%';

    // preview
    if(preview.style.display!=='none'){
      pctx.clearRect(0,0,preview.width,preview.height);
      pctx.drawImage(rawVideo,0,0,preview.width,preview.height);
      // dibuja nariz
      const nx = nose.x*preview.width, ny = nose.y*preview.height;
      pctx.fillStyle='#0f0'; pctx.beginPath(); pctx.arc(nx,ny,4,0,Math.PI*2); pctx.fill();
      pctx.fillStyle='#fff'; pctx.fillText(`NZ=${noseZ.toFixed(4)} base=${noseZNeutral.toFixed(4)} Œî=${noseDelta.toFixed(3)}`, 8, 16);
    }
  });

  // Calibraci√≥n nariz (neutro + delta)
  document.getElementById('calNose').onclick = async ()=>{
    alert('Mant√©n la cabeza en posici√≥n neutra mirando a la c√°mara ~2 s');
    const arr=[];
    const t0=performance.now();
    await new Promise(res=>{
      function loop(){ const t=performance.now();
        if(!isNaN(noseZ)) arr.push(noseZ);
        if(t-t0<2000) requestAnimationFrame(loop); else res();
      }
      requestAnimationFrame(loop);
    });
    if(arr.length){
      arr.sort((a,b)=>a-b);
      const m = arr[Math.floor(arr.length/2)];
      noseZNeutral = m;
      // delta por defecto relativo al tama√±o de la cara: aqu√≠ dejamos 0.02, ajusta si quieres m√°s/menos sensibilidad
      noseDelta = 0.02;
      alert(`Calibrado: NZ_neutro ‚âà ${noseZNeutral.toFixed(4)} | Œî = ${noseDelta.toFixed(3)} (empuja la cabeza levemente hacia adelante para dibujar)`);
    } else {
      alert('No se pudo medir NZ. Mejor luz y rostro centrado.');
    }
  };

  // ---- WebGazer (mirada) ----
  try{
    webgazer.setRegression('ridge'); webgazer.setTracker('TFFacemesh');
    if(webgazer.params){ webgazer.params.showVideoPreview=false; webgazer.params.showFaceFeedbackBox=false; webgazer.params.showPredictionPoints=false; }
    webgazer.begin();
  }catch(e){ showErr('webgazer init: '+e.message); }

  webgazer.setGazeListener((data)=>{ if(!data) return; gaze.x=data.x; gaze.y=data.y; });

  // ---- Calibraci√≥n mirada (af√≠n) ----
  document.getElementById('calGaze').onclick = async ()=>{
    const targets=[[0.08,0.08],[0.92,0.08],[0.92,0.92],[0.08,0.92],[0.50,0.50]];
    let gazePts=[], tgtPts=[];
    alert('Calibraci√≥n: mira esquinas y centro (1.6 s cada una)');
    for(const [nx,ny] of targets){
      const r=stageEl.getBoundingClientRect(); const tx=nx*r.width, ty=ny*r.height;
      const samples=[]; const t0=performance.now();
      await new Promise(res=>{ function loop(){ const t=performance.now();
        if(gaze.x!=null&&gaze.y!=null) samples.push([gaze.x,gaze.y]);
        if(t-t0<1600) requestAnimationFrame(loop); else res();
      } requestAnimationFrame(loop); });
      const [gx,gy]=mean2(samples); if(!isNaN(gx)&&!isNaN(gy)){ gazePts.push([gx,gy]); tgtPts.push([tx,ty]); }
      await sleep(200);
    }
    const sol=lsqAffine(gazePts,tgtPts); if(sol){A=sol.A; b=sol.b; alert('Calibraci√≥n OK ‚úÖ');} else alert('No se pudo calibrar');
  };

  // ---- loop principal (cursor + brocha con nariz) ----
  function loop(){
    if(gaze.x!=null && gaze.y!=null){
      const r=stageEl.getBoundingClientRect();
      const gx=gaze.x - r.left, gy=gaze.y - r.top;
      if(!smoothed) smoothed={x:gx,y:gy};
      smoothed.x=alpha*gx + (1-alpha)*smoothed.x;
      smoothed.y=alpha*gy + (1-alpha)*smoothed.y;
      const tx=A[0]*smoothed.x + A[1]*smoothed.y + b[0];
      const ty=A[2]*smoothed.x + A[3]*smoothed.y + b[1];
      const x=Math.max(0,Math.min(W-1,tx));
      const y=Math.max(0,Math.min(H-1,ty));

      if(mode!=='face'){
        cursor.style.display='block';
        cursor.style.left=x+'px'; cursor.style.top=y+'px';
        cursor.style.width=(brush*2)+'px'; cursor.style.height=(brush*2)+'px';
      } else { cursor.style.display='none'; }

      const active = noseActive();
      if(mode==='brush' && active){
        if(last){
          ctx.strokeStyle='rgba(0,200,255,.95)';
          ctx.lineWidth=brush; ctx.lineJoin='round'; ctx.lineCap='round';
          ctx.beginPath(); ctx.moveTo(last.x,last.y); ctx.lineTo(x,y); ctx.stroke();
          pts.push({t:Date.now(), x, y, nz:noseZ, active:1});
          countEl.textContent = `pts: ${pts.length}`;
        }
      }
      last={x,y};
    }
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);
  requestAnimationFrame(faceLoop);

  // ---- utils ----
  function sleep(ms){return new Promise(r=>setTimeout(r,ms));}
  function mean2(a){if(!a.length)return[NaN,NaN];const sx=a.reduce((s,v)=>s+v[0],0), sy=a.reduce((s,v)=>s+v[1],0);return[sx/a.length, sy/a.length];}
  function transpose(A){const m=A.length,n=A[0].length,AT=Array.from({length:n},()=>Array(m).fill(0));for(let i=0;i<m;i++)for(let j=0;j<n;j++)AT[j][i]=A[i][j];return AT;}
  function mul(A,B){const m=A.length,n=A[0].length,p=B[0].length,C=Array.from({length:m},()=>Array(p).fill(0));for(let i=0;i<m;i++)for(let k=0;k<n;k++)for(let j=0;j<p;j++)C[i][j]+=A[i][k]*B[k][j];return C;}
  function mulVec(A,v){const m=A.length,n=A[0].length,r=Array(m).fill(0);for(let i=0;i<m;i++)for(let j=0;j<n;j++)r[i]+=A[i][j]*v[j];return r;}
  function solveGaussian(A,b){const n=A.length,M=A.map((row,i)=>row.concat([b[i]]));for(let i=0;i<n;i++){let max=i;for(let r=i+1;r<n;r++)if(Math.abs(M[r][i])>Math.abs(M[max][i]))max=r;if(Math.abs(M[max][i])<1e-9)return null;[M[i],M[max]]=[M[max],M[i]];const piv=M[i][i];for(let k=i;k<=n;k++)M[i][k]/=piv;for(let r=0;r<n;r++)if(r!==i){const f=M[r][i];for(let k=i;k<=n;k++)M[r][k]-=f*M[i][k];}}return M.map(row=>row[n]);}
  function lsqAffine(gPts,tPts){const M=[],Z=[];for(let i=0;i<gPts.length;i++){const[gx,gy]=gPts[i];const[tx,ty]=tPts[i];M.push([gx,gy,0,0,1,0]);Z.push(tx);M.push([0,0,gx,gy,0,1]);Z.push(ty);}const Mt=transpose(M),MtM=mul(Mt,M),MtZ=mulVec(Mt,Z),p=solveGaussian(MtM,MtZ);return p?{A:[p[0],p[1],p[2],p[3]],b:[p[4],p[5]]}:null;}
})();
</script>
</body>
</html>
